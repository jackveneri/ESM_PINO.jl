var documenterSearchIndex = {"docs":
[{"location":"ref.html#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"ref.html#ESM_PINO.BurgersFD","page":"Reference","title":"ESM_PINO.BurgersFD","text":"BurgersFD{T}\n\nFinite Difference Scheme matrix for the Burgers equation with Periodic Boundary Conditions\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.BurgersFD2","page":"Reference","title":"ESM_PINO.BurgersFD2","text":"BurgersFD2{T}\n\nFinite Difference Scheme matrix for the Burgers equation with Periodic Boundary Conditions\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.ChannelMLP","page":"Reference","title":"ESM_PINO.ChannelMLP","text":"ChannelMLP(channels::Int; expansion_factor=2.0, activation=gelu)\n\nImplements a channel-wise MLP with a skip connection.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.ChannelMLP1D","page":"Reference","title":"ESM_PINO.ChannelMLP1D","text":"ChannelMLP1D(channels::Int; expansion_factor=0.5, activation=gelu)\n\nImplements a channel-wise MLP with a skip connection.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.ChannelMLP3D","page":"Reference","title":"ESM_PINO.ChannelMLP3D","text":"ChannelMLP3D(channels::Int; expansion_factor=0.5, activation=gelu)\n\nImplements a channel-wise MLP with a skip connection.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.FDPhysicsLossParameters","page":"Reference","title":"ESM_PINO.FDPhysicsLossParameters","text":"FDPhysicsLossParameters(ν::Float64, N_t::Int, t_max::Float64, t_min::Float64, Δt::Float64, x_σ::Float64, x_μ::Float64, M1_gpu::AbstractArray, M2_gpu::AbstractArray)\n\nCreate a struct to hold parameters for finite difference physics loss.\n\nFields\n\nν: Viscosity (scalar)\n'tsteplength`: Time step length (scalar)\nM1_gpu: Second derivative FD matrix (GPU array)\nM2_gpu: First derivative FD matrix (GPU array)\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.FNO_Block","page":"Reference","title":"ESM_PINO.FNO_Block","text":"FNO_Block{N}\n\nA block that combines a spectral kernel with a channel MLP. \n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.FNO_Block1D","page":"Reference","title":"ESM_PINO.FNO_Block1D","text":"FNO_Block1D\n\nA block that combines a spectral kernel with a channel MLP. \n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.FNO_Block3D","page":"Reference","title":"ESM_PINO.FNO_Block3D","text":"FNO_Block3D\n\nA block that combines a spectral kernel with a channel MLP. \n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.FourierNeuralOperator","page":"Reference","title":"ESM_PINO.FourierNeuralOperator","text":"FourierNeuralOperator\n\nA layer that combines the Fourier Neural Operator (FNO) with positional embeddings, spectral kernels, and channel MLPs.\n\nArguments\n\nin_channels::Int: Number of input channels.\nout_channels::Int: Number of output channels.\nhidden_channels::Int: Number of hidden channels in the FNO blocks.\nn_modes::NTuple{N,Integer}: Number of Fourier modes in each dimension (default is (16, 16)).\nn_layers::Int: Number of FNO blocks (default is 4).\nlifting_channel_ratio::Int: Ratio for the lifting layer (default is 2). \nprojection_channel_ratio::Int: Ratio for the projection layer (default is 2).\nchannel_mlp_expansion::Number: Expansion factor for the channel MLP (default is 0.5).\nactivation: Activation function (default is NNlib.gelu).\npositional_embedding::AbstractString: Type of positional embedding to use (default is \"grid\"). Options are \"grid\", \"nogrid\", \"grid1D\", \"nogrid1D\", \"grid3D\", and \"no_grid3D\".\n\nReturns\n\nFourierNeuralOperator: A layer that combines the Fourier Neural Operator with the specified configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.Grid","page":"Reference","title":"ESM_PINO.Grid","text":"Grid{T}\n\nDicretization grid for 1d finite difference schemes. \n\nInitialization\n\nGrid(x)\n\nwith x array or range with constant spacing \n\nFields\n\nN\nx::AbstractVector{T}\nΔx::T\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.GridEmbedding2D","page":"Reference","title":"ESM_PINO.GridEmbedding2D","text":"GridEmbedding2D(grid_boundaries=[[0f0, 1f0], [0f0, 1f0]])\n\nPositional embedding that appends a normalized 2D coordinate grid to input data.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.GridEmbedding3D","page":"Reference","title":"ESM_PINO.GridEmbedding3D","text":"GridEmbedding3D(grid_boundaries=[[0f0, 1f0], [0f0, 1f0], [0f0, 1f0]])\n\nPositional embedding that appends a normalized 3D coordinate grid to input data.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.NeumannFD","page":"Reference","title":"ESM_PINO.NeumannFD","text":"NeumannFD{T}\n\nFinite Difference Scheme matrix with Neumann Boundary Conditions, so that the derivative at the boundaries is zero\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.PeriodicFD","page":"Reference","title":"ESM_PINO.PeriodicFD","text":"PeriodicFD{T}\n\nFinite Difference Scheme matrix with Periodic Boundary Conditions\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.SoftGating","page":"Reference","title":"ESM_PINO.SoftGating","text":"SoftGating(channels::Int)\n\nA soft gating layer that applies per-channel multiplicative scaling.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.SoftGating1D","page":"Reference","title":"ESM_PINO.SoftGating1D","text":"SoftGating1D(channels::Int)\n\nA soft gating layer that applies per-channel multiplicative scaling.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.SoftGating3D","page":"Reference","title":"ESM_PINO.SoftGating3D","text":"SoftGating3D(channels::Int)\n\nA soft gating layer that applies per-channel multiplicative scaling.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.SpectralConv","page":"Reference","title":"ESM_PINO.SpectralConv","text":"SpectralConv{T,N}\n\nSpectral convolution layer for Fourier Neural Operator in Lux.jl. Expects input in (spatial..., channel, batch) format.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.SpectralKernel","page":"Reference","title":"ESM_PINO.SpectralKernel","text":"SpectralKernel{P,F}\n\nCombines a SpectralConv layer with a 1x1 convolution in parallel, followed by an activation function. Expects input in (spatial..., channel, batch) format.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.SpectralKernel1D","page":"Reference","title":"ESM_PINO.SpectralKernel1D","text":"SpectralKernel1D{P,F}\nCombines a SpectralConv layer with a 1x1 convolution in parallel, followed by an activation function.\n\nExpects input in (spatial, channel, batch) format.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.SpectralKernel3D","page":"Reference","title":"ESM_PINO.SpectralKernel3D","text":"SpectralKernel3D{P,F}\n\nCombines a SpectralConv layer with a 1x1 convolution in parallel, followed by an activation function. Expects input in (spatial..., channel, batch) format.\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.SpectralPhysicsLossParameters","page":"Reference","title":"ESM_PINO.SpectralPhysicsLossParameters","text":"SpectralPhysicsLossParameters(ν::Float64, L::Float64, N_t::Int, t_max::Float64, t_min::Float64, Δt::Float64, x_σ::Float64, x_μ::Float64)\n\nCreate a struct to hold parameters for spectral physics loss.\n\nFields\n\nν: Viscosity (scalar)\nL: Domain size (scalar)\nN_t: Number of time steps (integer)\nt_max: Maximum time (scalar)\nt_min: Minimum time (scalar)\nΔt: Time step size (scalar)\nx_σ: Standard deviation for normalization (scalar)\nx_μ: Mean for normalization (scalar)\n\n\n\n\n\n","category":"type"},{"location":"ref.html#ESM_PINO.apply_pattern-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T}}} where {T, N}","page":"Reference","title":"ESM_PINO.apply_pattern","text":"apply_pattern(x_tr::AbstractArray{T,N}, weights::AbstractArray{T,3}) where {T,N}\n\nApply learned weight patterns to truncated Fourier coefficients.\n\nArguments\n\nx_tr::AbstractArray{T,N}: Truncated Fourier coefficients after low-pass filtering, with shape (modes..., in_channels, batch)\nweights::AbstractArray{T,4}: Complex-valued learned weights with shape (modes..., outchannels, inchannels)\n\nReturns\n\nWeighted Fourier coefficients with shape (modes..., out_channels, batch)\n\n\n\n\n\n","category":"method"},{"location":"ref.html#ESM_PINO.autoregressive_loss-Tuple{LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer, Tuple{AbstractArray, AbstractArray}, Int64, ESM_PINO.FDPhysicsLossParameters, Float32}","page":"Reference","title":"ESM_PINO.autoregressive_loss","text":"autoregressive_loss(model::StatefulLuxLayer, (u0, target)::Tuple{AbstractArray, AbstractArray}, n_steps::Int, params::FDPhysicsLossParameters, λ::Float32)\n\nCompute autoregressive loss for a model over multiple time steps.\n\nArguments\n\nmodel: StatefulLuxLayer model\nu0: Initial state (input data)\ntarget: Target data for comparison\nn_steps: Number of time steps to propagate\nparams: FDPhysicsLossParameters struct containing physics parameters\nλ: Weighting factor for physics loss\n\nReturns\n\nTotal loss combining data loss and physics-informed loss\n\n\n\n\n\n","category":"method"},{"location":"ref.html#ESM_PINO.compute_k-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T<:Real","page":"Reference","title":"ESM_PINO.compute_k","text":"compute_k(u::AbstractArray{T}, L::T) where T<:Real\n\nGenerate wavenumber array for spectral differentiation.\n\nArguments\n\nu: Template array for dimensions\nL: Domain length\n\nRetuu_t1ns\n\nk: Wt2venumber array on GPU, reshaped for broadcastingt2\n\nDet2ails\n\nHandles even/odd array sizes differently\nAutt2matically converts to GPU array\nReturns array with singleton dimensions for ND broadcasting\n\n\n\n\n\n","category":"method"},{"location":"ref.html#ESM_PINO.create_physics_loss-Tuple{ESM_PINO.SpectralPhysicsLossParameters}","page":"Reference","title":"ESM_PINO.create_physics_loss","text":"create_physics_loss()\n\nhelper function to create a physics loss function.\n\nArguments\n\nparams: parameters struct, pass nothing to create a zero loss function.\n\n\n\n\n\n","category":"method"},{"location":"ref.html#ESM_PINO.dealias-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, T}} where T<:Real","page":"Reference","title":"ESM_PINO.dealias","text":"dealias(u_hat::AbstractArray{Complex{T}}, L::T) where T<:Real\n\nApply 2/3 dealiasing filter to Fourier coefficients.\n\nArguments\n\nu_hat: Fourier coefficients (complex array)\nL: Domain length (unused in current implementation)\n\nReturns\n\nFiltered coefficients with high frequencies zeroed\n\nNotes\n\nImplements 2/3 rule for anti-aliasing\nCreates mask directly on GPU\nPreserves array dimensions for broadcasting\n\n\n\n\n\n","category":"method"},{"location":"ref.html#ESM_PINO.expand_pad_dims-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N","page":"Reference","title":"ESM_PINO.expand_pad_dims","text":"expand_pad_dims(pad_dims::Dims{N}) where {N}\n\nConvert N-dimensional padding specification into format required for NNlib's pad_constant function.\n\nArguments\n\npad_dims::Dims{N}: Tuple of N integers specifying the total padding needed along each dimension\n\nReturns\n\nNTuple{2N,Int}: Tuple of 2N integers specifying padding for both sides of each dimension, where padding is applied only at the end of each dimension (start padding is always 0)\n\n\n\n\n\n","category":"method"},{"location":"ref.html#ESM_PINO.low_pass-Tuple{AbstractArray, Any}","page":"Reference","title":"ESM_PINO.low_pass","text":"low_pass(x_ft, modes)\n\nApply a low-pass filter to a Fourier-transformed array by retaining only the lowest frequency modes.\n\nArguments\n\nx_ft: A Fourier-transformed array with at least 2 trailing dimensions\nmodes: A tuple or array specifying the number of low-frequency modes to keep along each leading dimension\n\nReturns\n\nA view of the input array x_ft containing only the specified low-frequency modes, preserving the last two dimensions in full\n\nDetails\n\nThe function creates a view that selects the first modes[i] elements along each leading dimension i, while keeping all elements of the last two dimensions. This effectively implements a low-pass filter in Fourier space by truncating high-frequency modes.\n\n\n\n\n\n","category":"method"},{"location":"ref.html#ESM_PINO.meshgrid-Tuple{Any, Any}","page":"Reference","title":"ESM_PINO.meshgrid","text":"meshgrid(x, y) Generates a 2D meshgrid from vectors x and y.\n\n\n\n\n\n","category":"method"},{"location":"ref.html#ESM_PINO.mse_loss_function-Tuple{LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer, AbstractArray, AbstractArray}","page":"Reference","title":"ESM_PINO.mse_loss_function","text":"mse_loss_function(u::StatefulLuxLayer, target::AbstractArray, xt::AbstractArray)\n\nStandard mean squared error loss.\n\nArguments\n\nu: Neural network\ntarget: Ground truth values\nu_t1: Network inputs\n\nReturns\n\nMSE between network output and target\n\n\n\n\n\n","category":"method"},{"location":"ref.html#ESM_PINO.spectral_derivative-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T<:Real","page":"Reference","title":"ESM_PINO.spectral_derivative","text":"spectral_derivative(u::AbstractArray{T}, L::T) where T<:Real\n\nCompute first and second spatial derivatives using FFT spectral methods.\n\nArguments\n\nu: Input array (real-valued), assumed to be on GPU. First dimension is spatial.\nL: Domain length in spatial dimension.\n\nReturns\n\ndu: First derivative (real array)\nd2u: Second derivative (real array)\n\nNotes\n\nUses FFT/iFFT with wavenumbers from compute_k\nAssumes periodic boundary conditions\nMaintains input array type/location (GPU/CPU)\nOutput derivatives are real-valued arrays\n\n\n\n\n\n","category":"method"},{"location":"index.html#ESM_PINO","page":"Home","title":"ESM_PINO","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Documentation for ESM_PINO.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"}]
}
