<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QG3 Extension · ESM_PINO.jl</title><meta name="title" content="QG3 Extension · ESM_PINO.jl"/><meta property="og:title" content="QG3 Extension · ESM_PINO.jl"/><meta property="twitter:title" content="QG3 Extension · ESM_PINO.jl"/><meta name="description" content="Documentation for ESM_PINO.jl."/><meta property="og:description" content="Documentation for ESM_PINO.jl."/><meta property="twitter:description" content="Documentation for ESM_PINO.jl."/><meta property="og:url" content="https://jackveneri.github.io/ESM_PINO.jl/extensions/QG3/"/><meta property="twitter:url" content="https://jackveneri.github.io/ESM_PINO.jl/extensions/QG3/"/><link rel="canonical" href="https://jackveneri.github.io/ESM_PINO.jl/extensions/QG3/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ESM_PINO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../ref/">Reference</a></li><li class="is-active"><a class="tocitem" href>QG3 Extension</a></li><li><a class="tocitem" href="../SpeedyWeather/">SpeedyWeather Extension</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>QG3 Extension</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>QG3 Extension</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jackveneri/ESM_PINO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jackveneri/ESM_PINO.jl/blob/master/docs/src/extensions/QG3.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="QG3-Extension"><a class="docs-heading-anchor" href="#QG3-Extension">QG3 Extension</a><a id="QG3-Extension-1"></a><a class="docs-heading-anchor-permalink" href="#QG3-Extension" title="Permalink"></a></h1><p>This page documents the QG3-based SFNO layers and utility functions defined to work with the QG3 package</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINO.SFNO-Tuple{QG3.GaussianGridtoSHTransform, QG3.SHtoGaussianGridTransform}" href="#ESM_PINO.SFNO-Tuple{QG3.GaussianGridtoSHTransform, QG3.SHtoGaussianGridTransform}"><code>ESM_PINO.SFNO</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SFNO(
    ggsh::QG3.GaussianGridtoSHTransform,
    shgg::QG3.SHtoGaussianGridTransform;
    modes,
    in_channels,
    out_channels,
    hidden_channels,
    n_layers,
    lifting_channel_ratio,
    projection_channel_ratio,
    channel_mlp_expansion,
    activation,
    positional_embedding,
    inner_skip,
    outer_skip,
    zsk,
    use_norm,
    downsampling_factor,
    gpu,
    batch_size
) -&gt; Union{SFNO{GridEmbedding2D, L, _A, P, ESM_PINOQG3Ext.ESM_PINOQG3} where {L&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A)), _A, P&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A))}, SFNO{Lux.NoOpLayer, L, _A, P, ESM_PINOQG3Ext.ESM_PINOQG3} where {L&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A)), _A, P&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A))}}
</code></pre><p>Spherical Fourier Neural Operator (SFNO) layer combining positional embeddings, spectral kernels, and channel MLPs.</p><p>This layer implements the SFNO architecture on the sphere, optionally using Zonal Symmetric Kernels (ZSK) following the approach described in <a href="https://arxiv.org/abs/2204.06408"><strong>Spherical Fourier Neural Operators: Learning Stable Dynamics on the Sphere</strong></a>.</p><p><strong>Arguments</strong></p><ul><li><code>ggsh::QG3.GaussianGridtoSHTransform</code>: Precomputed grid-to-SH transform.</li><li><code>shgg::QG3.SHtoGaussianGridTransform</code>: Precomputed SH-to-grid transform.</li><li>Other keyword arguments are the same as for the primary constructor, except modes which default is set to <code>ggsh.output_size[1]</code>. Also, no need to specify <code>batch_size</code> or <code>gpu</code> as these are handled in the transforms.</li></ul><p><strong>Returns</strong></p><ul><li><code>SFNO</code>: A Lux-compatible container layer.</li></ul><p><strong>Details</strong></p><ul><li>Constructs lifting, SFNO blocks, and projection layers compatible with Lux.jl.</li><li>Positional embeddings are appended if <code>positional_embedding=&quot;grid&quot;</code>.</li><li>Supports both CPU and GPU execution.</li><li>Zonal Symmetric Kernels (ZSK) reduce the number of parameters and improve stability on spherical domains.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Lux, QG3, Random, NNlib, LuxCUDA

# Load precomputed QG3 parameters
qg3ppars = QG3.load_precomputed_params()[2]

# Input: [lat, lon, channels, batch]
x = rand(Float32, 32, 64, 3, 10)


# Construct SFNO layer using secondary constructor
ggsh = QG3.GaussianGridtoSHTransform(qg3ppars, 32, N_batch=size(x,4))
shgg = QG3.SHtoGaussianGridTransform(qg3ppars, 32, N_batch=size(x,4))
model2 = SFNO(ggsh, shgg;
    modes=15,
    in_channels=3,
    out_channels=3,
    hidden_channels=32,
    n_layers=4,
    lifting_channel_ratio=2,
    projection_channel_ratio=2,
    channel_mlp_expansion=2.0,
    positional_embedding=&quot;no_grid&quot;,
    outer_skip=true,
    zsk=true
)

# Setup parameters and state
rng = Random.default_rng(0)
ps, st = Lux.setup(rng, model2)

# Forward pass
y, st = model2(x, ps, st)

# Compute gradients
using Zygote
gr = Zygote.gradient(ps -&gt; sum(model2(x, ps, st)[1]), ps)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/SFNO.jl#L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINO.SFNO-Tuple{QG3ModelParameters}" href="#ESM_PINO.SFNO-Tuple{QG3ModelParameters}"><code>ESM_PINO.SFNO</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SFNO(
    pars::QG3ModelParameters;
    batch_size,
    modes,
    in_channels,
    out_channels,
    hidden_channels,
    n_layers,
    lifting_channel_ratio,
    projection_channel_ratio,
    channel_mlp_expansion,
    activation,
    positional_embedding,
    inner_skip,
    outer_skip,
    zsk,
    use_norm,
    downsampling_factor,
    gpu
) -&gt; Union{SFNO{GridEmbedding2D, L, _A, P, ESM_PINOQG3Ext.ESM_PINOQG3} where {L&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A)), _A, P&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A))}, SFNO{Lux.NoOpLayer, L, _A, P, ESM_PINOQG3Ext.ESM_PINOQG3} where {L&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A)), _A, P&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A))}}
</code></pre><p>Spherical Fourier Neural Operator (SFNO) layer combining positional embeddings, spectral kernels, and channel MLPs.</p><p>This layer implements the SFNO architecture on the sphere, optionally using Zonal Symmetric Kernels (ZSK) following the approach described in <a href="https://arxiv.org/abs/2204.06408"><strong>Spherical Fourier Neural Operators: Learning Stable Dynamics on the Sphere</strong></a>.</p><p><strong>Arguments</strong></p><ul><li><code>pars::QG3ModelParameters</code>: Model parameters defining the spherical grid and maximum spherical harmonic degree <code>L</code>.</li><li><code>batch_size::Int=1</code>: Number of samples in a batch.</li><li><code>modes::Int=pars.L</code>: Maximum number of spherical harmonic modes to use.</li><li><code>in_channels::Int</code>: Number of input channels.</li><li><code>out_channels::Int</code>: Number of output channels.</li><li><code>hidden_channels::Int=32</code>: Number of hidden channels in the SFNO blocks.</li><li><code>n_layers::Int=4</code>: Number of SFNO blocks.</li><li><code>lifting_channel_ratio::Int=2</code>: Expansion ratio for the lifting layer.</li><li><code>projection_channel_ratio::Int=2</code>: Expansion ratio for the projection layer.</li><li><code>channel_mlp_expansion::Number=2.0</code>: Expansion factor for channel MLPs in each SFNO block.</li><li><code>activation</code>: Activation function (default is <code>NNlib.gelu</code>).</li><li><code>positional_embedding::AbstractString=&quot;grid&quot;</code>: Type of positional embedding. Options: <code>&quot;grid&quot;</code> or <code>&quot;no_grid&quot;</code>.</li><li><code>inner_skip::Bool=true</code>: If true, use skip connections inside each SFNO block.</li><li><code>outer_skip::Bool=true</code>: If true, apply residual connection from lifting output to projection output.</li><li><code>gpu::Bool=true</code>: If true, computations are performed on GPU.</li><li><code>zsk::Bool=false</code>: If true, use Zonal Symmetric Kernels, enforcing longitudinal symmetry.</li></ul><p><strong>Returns</strong></p><ul><li><code>SFNO</code>: A Lux-compatible container layer.</li></ul><p><strong>Details</strong></p><ul><li>Constructs lifting, SFNO blocks, and projection layers compatible with Lux.jl.</li><li>Positional embeddings are appended if <code>positional_embedding=&quot;grid&quot;</code>.</li><li>Supports both CPU and GPU execution.</li><li>Zonal Symmetric Kernels (ZSK) reduce the number of parameters and improve stability on spherical domains.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Lux, QG3, Random, NNlib, LuxCUDA

# Load precomputed QG3 parameters
qg3ppars = QG3.load_precomputed_params()[2]

# Input: [lat, lon, channels, batch]
x = rand(Float32, 32, 64, 3, 10)

# Construct SFNO layer using primary constructor
model1 = SFNO(qg3ppars;
    batch_size=size(x, 4),
    modes=30,
    in_channels=3,
    out_channels=3,
    hidden_channels=32,
    n_layers=4,
    lifting_channel_ratio=2,
    projection_channel_ratio=2,
    channel_mlp_expansion=2.0,
    positional_embedding=&quot;no_grid&quot;,
    outer_skip=true,
    gpu=false
)


# Setup parameters and state
rng = Random.default_rng(0)
ps, st = Lux.setup(rng, model1)

# Forward pass
y, st = model1(x, ps, st)

# Compute gradients
using Zygote
gr = Zygote.gradient(ps -&gt; sum(model1(x, ps, st)[1]), ps)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/SFNO.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINO.SFNO_Block-Tuple{Int64, QG3.GaussianGridtoSHTransform, QG3.SHtoGaussianGridTransform}" href="#ESM_PINO.SFNO_Block-Tuple{Int64, QG3.GaussianGridtoSHTransform, QG3.SHtoGaussianGridTransform}"><code>ESM_PINO.SFNO_Block</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SFNO_Block(
    channels::Int64,
    ggsh::QG3.GaussianGridtoSHTransform,
    shgg::QG3.SHtoGaussianGridTransform;
    modes,
    expansion_factor,
    activation,
    skip,
    zsk,
    use_norm
) -&gt; ESM_PINO.SFNO_Block{ESM_PINOQG3Ext.ESM_PINOQG3}
</code></pre><p>A block that combines a spherical kernel with a channel MLP. Expects input in (spatial..., channel, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>channels::Int</code>: Number of input/output channels</li><li><code>ggsh::GaussianGridtoSHTransform</code>: Transformation from Gaussian grid to spherical harmonics</li><li><code>shgg::SHtoGaussianGridTransform</code>: Transformation from spherical harmonics back to Gaussian</li><li><code>modes::Int=ggsh.output_size[1]</code>: Number of spherical harmonic modes to retain (default: <code>ggsh.output_size[1]</code>)</li><li><code>expansion_factor::Real=2.0</code>: Expansion factor for the ChannelMLP (default: 2.0)</li><li><code>activation</code>: Activation function applied after combining spatial and spectral branches (default: <code>NNlib.gelu</code>)</li><li><code>skip::Bool=true</code>: Whether to include a skip connection (default: true)</li><li><code>zsk::Bool=false</code>: Whether to use Zonal Symmetric Kernels (ZSK) (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>SFNO_Block</code>: A Lux-compatible layer operating on 4D arrays <code>[lat, lon, channels, batch]</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>spherical_kernel::SphericalKernel</code>: Spherical kernel layer</li><li><code>channel_mlp::ChannelMLP</code>: Channel-wise MLP layer</li><li><code>channels::Int</code>: Number of input/output channels</li><li><code>skip::Bool</code>: Whether to include a skip connection</li></ul><p><strong>Details</strong></p><ul><li>The input is processed by a SphericalKernel followed by a ChannelMLP</li><li>If <code>skip</code> is true, the input is added to the output (residual connection)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/SFNO_components.jl#L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINO.SFNO_Block-Tuple{Int64, QG3ModelParameters}" href="#ESM_PINO.SFNO_Block-Tuple{Int64, QG3ModelParameters}"><code>ESM_PINO.SFNO_Block</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SFNO_Block(
    channels::Int64,
    pars::QG3ModelParameters;
    modes,
    batch_size,
    expansion_factor,
    activation,
    skip,
    gpu,
    zsk,
    use_norm
) -&gt; ESM_PINO.SFNO_Block{ESM_PINOQG3Ext.ESM_PINOQG3}
</code></pre><p>A block that combines a spherical kernel with a channel MLP. Expects input in (spatial..., channel, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>channels::Int</code>: Number of input/output channels</li><li><code>pars::QG3ModelParameters</code>: Precomputed QG3 model parameters (QG3ModelParameters)</li><li><code>modes::Int=pars.L</code>: Number of spherical harmonic modes to retain (default: <code>pars.L</code>)</li><li><code>batch_size::Int=1</code>: Batch size for transforms (default: 1)</li><li><code>expansion_factor::Real=2.0</code>: Expansion factor for the ChannelMLP (default: 2.0)</li><li><code>activation</code>: Activation function applied after combining spatial and spectral branches (default: <code>NNlib.gelu</code>)</li><li><code>skip::Bool=true</code>: Whether to include a skip connection (default: true)</li><li><code>gpu::Bool=true</code>: Whether to use GPU (default: true)</li><li><code>zsk::Bool=false</code>: Whether to use Zonal Symmetric Kernels (ZSK) (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>SFNO_Block</code>: A Lux-compatible layer operating on 4D arrays <code>[lat, lon, channels, batch]</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>spherical_kernel::SphericalKernel</code>: Spherical kernel layer</li><li><code>channel_mlp::ChannelMLP</code>: Channel-wise MLP layer</li><li><code>channels::Int</code>: Number of input/output channels</li><li><code>skip::Bool</code>: Whether to include a skip connection</li></ul><p><strong>Details</strong></p><ul><li>The input is processed by a SphericalKernel followed by a ChannelMLP</li><li>If <code>skip</code> is true, the input is added to the output (residual connection)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/SFNO_components.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINO.SphericalConv" href="#ESM_PINO.SphericalConv"><code>ESM_PINO.SphericalConv</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalConv(
    hidden_channels::Int64,
    ggsh::QG3.GaussianGridtoSHTransform,
    shgg::QG3.SHtoGaussianGridTransform;
    ...
) -&gt; ESM_PINO.SphericalConv{ESM_PINOQG3Ext.ESM_PINOQG3}
SphericalConv(
    hidden_channels::Int64,
    ggsh::QG3.GaussianGridtoSHTransform,
    shgg::QG3.SHtoGaussianGridTransform,
    modes::Int64;
    zsk
) -&gt; ESM_PINO.SphericalConv{ESM_PINOQG3Ext.ESM_PINOQG3}
</code></pre><p>Spherical convolution layer for functions on the sphere using spherical harmonics.   Transforms data from Gaussian grid → spherical harmonics, applies learned weights, and transforms back.</p><p><strong>Arguments</strong></p><ul><li><code>hidden_channels::Int</code>: Number of input/output channels.</li><li><code>ggsh::GaussianGridtoSHTransform</code>: Transformation from Gaussian grid to spherical harmonics.</li><li><code>shgg::SHtoGaussianGridTransform</code>: Transformation from spherical harmonics back to Gaussian grid.</li><li><code>modes::Int=ggsh.output_size[1]</code>: Maximum number of spherical harmonic modes to use. If higher than <code>ggsh.output_size[1]</code>, it is truncated with a warning.</li><li><code>zsk::Bool=false</code>: If true, uses Zonal Symmetric Kernels (ZSK), reducing the number of free weights. It follows <a href="https://arxiv.org/abs/2204.06408"><strong>Spherical Fourier Neural Operators: Learning Stable Dynamics on the Sphere</strong></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>SphericalConv</code>: A Lux-compatible layer operating on 4D arrays <code>[lat, lon, channels, batch]</code>.</li></ul><p><strong>Details</strong></p><ul><li>Input is permuted internally to <code>[channels, lat, lon, batch]</code> for computation.</li><li>Uses <code>ps.weight</code> for element-wise multiplication in spherical harmonic space.</li><li>Supports padding to match the original spherical grid dimensions.</li><li>Compatible with GPU and CPU (controlled externally in ggsh, shgg constructor).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Random, Lux, QG3, NNlib

# Load precomputed spherical model parameters
qg3ppars = QG3.load_precomputed_params()[2]

# Create transforms
ggsh = QG3.GaussianGridtoSHTransform(qg3ppars, 32, N_batch=1)
shgg = QG3.SHtoGaussianGridTransform(qg3ppars, 32, N_batch=1)

# Initialize layer
layer = SphericalConv(32, ggsh, shgg, 30; zsk=true)

# Generate random input [lat, lon, channels, batch]
x = rand(Float32, 32, 64, 32, 1)

# Setup parameters and state
rng = Random.default_rng(0)
ps, st = Lux.setup(rng, layer)

# Forward pass
y, st = layer(x, ps, st)

# Compute gradient
using Zygote
gr = Zygote.gradient(ps -&gt; sum(layer(x, ps, st)[1]), ps)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/SphericalConvTypeSpec.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINO.SphericalConv-Union{Tuple{T}, Tuple{QG3ModelParameters{T, I, A, M} where {I&lt;:Int64, A&lt;:AbstractVector{T}, M&lt;:AbstractMatrix{T}}, Int64}} where T" href="#ESM_PINO.SphericalConv-Union{Tuple{T}, Tuple{QG3ModelParameters{T, I, A, M} where {I&lt;:Int64, A&lt;:AbstractVector{T}, M&lt;:AbstractMatrix{T}}, Int64}} where T"><code>ESM_PINO.SphericalConv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalConv(
    pars::QG3ModelParameters{T, I, A, M} where {I&lt;:Int64, A&lt;:AbstractArray{T, 1}, M&lt;:AbstractArray{T, 2}},
    hidden_channels::Int64;
    modes,
    batch_size,
    gpu,
    zsk
) -&gt; ESM_PINO.SphericalConv{ESM_PINOQG3Ext.ESM_PINOQG3}
</code></pre><p>Construct a spherical convolution layer using precomputed model parameters.</p><p><strong>Arguments</strong></p><ul><li><code>pars::QG3.QG3ModelParameters{T}</code>: Model parameters defining the spherical grid resolution and maximum spherical harmonic degree <code>L</code>.</li><li><code>hidden_channels::Int</code>: Number of input/output channels.</li><li><code>modes::Int=pars.L</code>: Maximum number of spherical harmonic modes to use. If higher than <code>pars.L</code>, it is truncated with a warning.</li><li><code>batch_size::Int=1</code>: Number of samples in a batch (used for internal transforms).</li><li><code>gpu::Bool=true</code>: If true, computations are moved to GPU using <code>QG3.gpuon()</code>.</li><li><code>zsk::Bool=false</code>: If true, uses Zonal Symmetric Kernels (ZSK), reducing the number of free weights. ZSK enforces rotational symmetry along longitude and follows <a href="https://arxiv.org/abs/2204.06408"><strong>Spherical Fourier Neural Operators: Learning Stable Dynamics on the Sphere</strong></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>SphericalConv</code>: A Lux-compatible layer operating on 4D arrays <code>[lat, lon, channels, batch]</code>.</li></ul><p><strong>Details</strong></p><ul><li>Internally constructs <code>GaussianGridtoSHTransform</code> and <code>SHtoGaussianGridTransform</code> objects for the given <code>pars</code> and <code>hidden_channels</code>.</li><li>Corrects the requested <code>modes</code> to not exceed <code>pars.L</code>.</li><li>Supports both CPU and GPU computation.</li><li>Zonal Symmetric Kernels (ZSK) reduce the number of learnable parameters by enforcing symmetry along longitude, improving stability for spherical dynamics.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Random, Lux, QG3, NNlib

# Load precomputed parameters
qg3ppars = QG3.load_precomputed_params()[2]

# Initialize spherical convolution layer
layer = SphericalConv(qg3ppars, 32; modes=30, batch_size=1, gpu=false, zsk=true)

# Generate random input [lat, lon, channels, batch]
x = rand(Float32, 64, 128, 32, 1)

# Setup parameters and state
rng = Random.default_rng(0)
ps, st = Lux.setup(rng, layer)

# Forward pass
y, st = layer(x, ps, st)

# Compute gradient
using Zygote
gr = Zygote.gradient(ps -&gt; sum(layer(x, ps, st)[1]), ps)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/SphericalConvTypeSpec.jl#L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINO.SphericalKernel" href="#ESM_PINO.SphericalKernel"><code>ESM_PINO.SphericalKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalKernel(
    hidden_channels::Int64,
    pars::QG3ModelParameters;
    ...
) -&gt; ESM_PINO.SphericalKernel{ESM_PINOQG3Ext.ESM_PINOQG3}
SphericalKernel(
    hidden_channels::Int64,
    pars::QG3ModelParameters,
    activation;
    modes,
    batch_size,
    gpu,
    zsk
) -&gt; ESM_PINO.SphericalKernel{ESM_PINOQG3Ext.ESM_PINOQG3}
</code></pre><p>Combines a SphericalConv layer with a 1x1 convolution in parallel, followed by an activation function. Expects input in (spatial..., channel, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>hidden_channels</code>: Number of channels</li><li><code>pars</code>: Precomputed QG3 model parameters (QG3ModelParameters)</li><li><code>activation</code>: Activation function applied after combining spatial and spectral branches (default: <code>NNlib.gelu</code>)</li><li><code>modes</code>: Number of spherical harmonic modes to retain (default: <code>pars.L</code>)</li><li><code>batch_size</code>: Batch size for transforms (default: 1)</li><li><code>gpu</code>: Whether to use GPU (default: true)</li><li><code>zsk</code>: Whether to use Zonal Symmetric Kernels (ZSK) (default: false)</li></ul><p>#Returns</p><ul><li><code>SphericalKernel</code>: A Lux-compatible layer operating on 4D arrays `[lat,</li></ul><p><strong>Fields</strong></p><ul><li><code>spatial_conv::P</code>: 1x1 convolution operating directly in the spatial domain</li><li><code>spherical_conv::SphericalalConv</code>: Spherical convolution layer</li><li><code>activation::F</code>: Elementwise activation function</li></ul><p><strong>Details</strong></p><ul><li>The input is processed in parallel by a 1x1 convolution and a spherical convolution</li><li>Outputs from both branches are summed and passed through the activation</li><li>Useful for mixing local (spatial) and global (spectral) information</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/SFNO_components.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINO.SphericalKernel" href="#ESM_PINO.SphericalKernel"><code>ESM_PINO.SphericalKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SphericalKernel(
    hidden_channels::Int64,
    ggsh::QG3.GaussianGridtoSHTransform,
    shgg::QG3.SHtoGaussianGridTransform;
    ...
) -&gt; ESM_PINO.SphericalKernel{ESM_PINOQG3Ext.ESM_PINOQG3}
SphericalKernel(
    hidden_channels::Int64,
    ggsh::QG3.GaussianGridtoSHTransform,
    shgg::QG3.SHtoGaussianGridTransform,
    activation;
    modes,
    zsk
) -&gt; ESM_PINO.SphericalKernel{ESM_PINOQG3Ext.ESM_PINOQG3}
</code></pre><p>Construct a SphericalKernel layer using precomputed transforms.</p><p><strong>Arguments</strong></p><ul><li><code>hidden_channels::Int</code>: Number of channels</li><li><code>ggsh::GaussianGridtoSHTransform</code>: Transformation from Gaussian grid to spherical harmonics</li><li><code>shgg::SHtoGaussianGridTransform</code>: Transformation from spherical harmonics back to Gaussian grid</li><li><code>activation</code>: Activation function applied after combining spatial and spectral branches (default: <code>NNlib.gelu</code>)</li><li><code>modes::Int=ggsh.output_size[1]</code>: Number of spherical harmonic modes to retain (default: <code>ggsh.output_size[1]</code>)</li><li><code>zsk::Bool=false</code>: Whether to use Zonal Symmetric Kernels (ZSK) (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>SphericalKernel</code>: A Lux-compatible layer operating on 4D arrays <code>[lat, lon, channels, batch]</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>spatial_conv::P</code>: 1x1 convolution operating directly in the spatial domain</li><li><code>spherical_conv::SphericalalConv</code>: Spherical convolution layer</li><li><code>activation::F</code>: Elementwise activation function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/SFNO_components.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINOQG3Ext.QG3_Physics_Parameters-Tuple{}" href="#ESM_PINOQG3Ext.QG3_Physics_Parameters-Tuple{}"><code>ESM_PINOQG3Ext.QG3_Physics_Parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QG3_Physics_Parameters(
;
    n_lat,
    modes,
    batch_size
) -&gt; ESM_PINOQG3Ext.QG3_Physics_Parameters
</code></pre><p>Helper constructor to pass as empty default to train_model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/losses.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINOQG3Ext.fine_tuning-Tuple{AbstractArray, AbstractArray, Any, NamedTuple, NamedTuple}" href="#ESM_PINOQG3Ext.fine_tuning-Tuple{AbstractArray, AbstractArray, Any, NamedTuple, NamedTuple}"><code>ESM_PINOQG3Ext.fine_tuning</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fine_tuning(
    x::AbstractArray,
    target::AbstractArray,
    model,
    ps::NamedTuple,
    st::NamedTuple;
    n_steps,
    maxiters,
    lr_0,
    parameters,
    use_physics,
    geometric,
    α
) -&gt; LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer{Val{true}, var&quot;#s179&quot;, _A, NamedTuple{names, T}} where {var&quot;#s179&quot;&lt;:LuxCore.AbstractLuxLayer, _A, names, T&lt;:Tuple}
</code></pre><p>Fine-tune a pretrained <code>SFNO</code> model using an autoregressive (AR) loss function.   This procedure is typically applied after initial training to improve multi-step forecast accuracy.</p><p>The function performs a short fine-tuning loop with autoregressive supervision, optionally including a physics-informed loss component.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: Input data tensor.</li><li><code>target::AbstractArray</code>: Target data tensor with shape <code>(lat, lon, channels, batch, time)</code>.</li><li><code>model</code>: Pretrained <code>SFNO</code> model to be fine-tuned.</li><li><code>ps::NamedTuple</code>: Model parameters (from previous training).</li><li><code>st::NamedTuple</code>: Model internal state.</li></ul><p><strong>Keywords</strong></p><ul><li><code>n_steps::Int=2</code>: Number of autoregressive steps in the loss function.</li><li><code>maxiters::Int=5</code>: Maximum number of fine-tuning iterations.</li><li><code>lr_0::Float64=1e-5</code>: Learning rate for fine-tuning.</li><li><code>parameters::QG3_Physics_Parameters=QG3_Physics_Parameters()</code>: Physical parameters used in the loss.</li><li><code>use_physics::Bool=true</code>: Include physics-informed component in the loss if <code>true</code>.</li><li><code>geometric::Bool=true</code>: Use geometric formulation of the physics loss.</li><li><code>α::Float32=0.7f0</code>: Weighting factor between physics and data loss terms.</li></ul><p><strong>Returns</strong></p><ul><li><code>StatefulLuxLayer{true}</code>: Fine-tuned model instance with updated parameters and states.</li></ul><p><strong>Notes</strong></p><ul><li>The target tensor must have five dimensions, with the number of autoregressive steps as the fifth dimension.</li><li>The time dimension (<code>size(target, 5)</code>) must match the number of autoregressive steps (<code>n_steps</code>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Fine-tune a pretrained SFNO model for multi-step forecasting
ft_model = fine_tuning(x_val, y_val, pretrained_model, ps, st;
                       n_steps=3, maxiters=10, lr_0=1e-5)

# Evaluate fine-tuned model
pred = ft_model(x_val)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/utilities.jl#L360-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINOQG3Ext.make_QG3_loss-Tuple{ESM_PINOQG3Ext.QG3_Physics_Parameters}" href="#ESM_PINOQG3Ext.make_QG3_loss-Tuple{ESM_PINOQG3Ext.QG3_Physics_Parameters}"><code>ESM_PINOQG3Ext.make_QG3_loss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_QG3_loss(pars::QG3_Physics_Parameters;
              α=0.5f0,
              use_physics::Bool=true,
              geometric::Bool=false)</code></pre><p>Create a composite QG3 loss function suitable for Lux training. Returns a callable <code>(model, ps, st, (input, target)) -&gt; (loss, st, metrics)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/losses.jl#L113-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINOQG3Ext.make_autoregressive_loss-Tuple{Function}" href="#ESM_PINOQG3Ext.make_autoregressive_loss-Tuple{Function}"><code>ESM_PINOQG3Ext.make_autoregressive_loss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_autoregressive_loss(QG3_loss::Function; steps::Int, sequential::Bool=true)</code></pre><p>Create an autoregressive loss function that rolls out predictions over <code>steps</code> and accumulates the loss defined by <code>QG3_loss</code>.</p><p><strong>Arguments</strong></p><ul><li><code>QG3_loss</code>: A loss function of the form <code>(model, ps, st, (input, target)) -&gt; (loss, st, details)</code></li><li><code>steps</code>: Number of autoregressive rollout steps</li><li><code>sequential</code>: If true, predictions are fed sequentially (standard autoregressive); if false, all predictions are computed and compared in batch for efficiency.</li></ul><p><strong>Returns</strong></p><ul><li>A loss function <code>(model, ps, st, (u_t1, targets)) -&gt; (loss, st, details)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/losses.jl#L160-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINOQG3Ext.remap_plan" href="#ESM_PINOQG3Ext.remap_plan"><code>ESM_PINOQG3Ext.remap_plan</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remap_plan(
    l::Integer,
    c::Integer;
    ...
) -&gt; NamedTuple{(:remap_fixed, :mask, :new_indices), &lt;:Tuple{Any, Any, Any}}
remap_plan(
    l::Integer,
    c::Integer,
    T::Type{&lt;:Number};
    gpu
) -&gt; NamedTuple{(:remap_fixed, :mask, :new_indices), &lt;:Tuple{Any, Any, Any}}
</code></pre><p>Precompute a symmetric remapping plan between index ranges [-l..l] and [-c..c+1). This is used to ensure correct ordering and slicing of spectral coefficients on gpu</p><p><strong>Arguments</strong></p><p>-<code>l::Integer</code>: Original spectral truncation (maximum mode index).</p><p>-<code>c::Integer</code>: half-length of gpu-array rows.</p><p>-<code>T::Type{&lt;:Number}=Float32</code>: Element type for masks and indices.</p><p><strong>Keywords</strong></p><ul><li><code>gpu::Bool=true</code>: Whether to allocate the mask on the GPU (CuArray).</li></ul><p><strong>Returns</strong></p><p>NamedTuple with:</p><ul><li><p><code>remap_fixed::Vector{Int}</code> — Mapped indices (0 replaced with 1).</p></li><li><p><code>mask::AbstractArray</code> — Binary mask (CPU or GPU) for valid indices.</p></li><li><p><code>new_indices::Vector{Int}</code> — Target symmetric indices.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">plan = remap_plan(42, 63; gpu=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/utilities.jl#L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINOQG3Ext.remap_symmetric_dim-Tuple{AbstractArray, Any}" href="#ESM_PINOQG3Ext.remap_symmetric_dim-Tuple{AbstractArray, Any}"><code>ESM_PINOQG3Ext.remap_symmetric_dim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remap_symmetric_dim(
    A::AbstractArray,
    plan;
    dim,
    fill_value
) -&gt; Tuple{Any, Any}
</code></pre><p>Apply a precomputed symmetric remapping plan along a given array dimension. Works on both CPU and GPU arrays and is compatible with Zygote for AD.</p><p><strong>Arguments</strong></p><p>-<code>A::AbstractArray</code>: Input tensor to be remapped.</p><p>-<code>plan</code>: Remapping structure returned by remap_plan.</p><p><strong>Keywords</strong></p><p>-<code>dim::Integer=3</code>: Dimension along which to apply the remap.</p><p>-<code>fill_value</code>: Optional value for indices outside the valid range. Defaults to zero(eltype(A)).</p><p><strong>Returns</strong></p><ul><li><code>(C, new_indices)</code>: Tuple with the remapped array and the list of new indices.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">plan = remap_plan(42, 63)
A_new, idx = remap_symmetric_dim(A, plan; dim=3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/utilities.jl#L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINOQG3Ext.stack_time_steps-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Int64}} where T" href="#ESM_PINOQG3Ext.stack_time_steps-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Int64}} where T"><code>ESM_PINOQG3Ext.stack_time_steps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stack_time_steps(
    data::AbstractArray{T, 4},
    time_steps::Int64
) -&gt; Any
</code></pre><p>Convert a 4D tensor of sequential data <code>(lat, lon, channels, batch)</code> into a 5D tensor suitable for autoregressive training or evaluation.   The function constructs overlapping sequences along the batch dimension, each containing <code>time_steps</code> consecutive snapshots.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractArray{T,4}</code>: Input data tensor with dimensions <code>(lat, lon, channels, batch)</code>.</li><li><code>time_steps::Int</code>: Number of consecutive time steps to include in each sequence.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{T,5}</code>: A 5D tensor of shape <code>(lat, lon, channels, time_steps, n_sequences)</code>, where <code>n_sequences = batch - time_steps + 1</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The resulting array can be used as autoregressive training targets for multi-step prediction.</li><li>Sequences are created by sliding a window of length <code>time_steps</code> along the batch axis.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Input: 4D array with 10 time samples
data = rand(Float32, 64, 128, 3, 10)

# Stack into 5D sequences of 4 time steps each
seq_data = stack_time_steps(data, 4)

@assert size(seq_data) == (64, 128, 3, 4, 7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/utilities.jl#L478-L508">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINOQG3Ext.train_model-Tuple{AbstractArray, AbstractArray, QG3ModelParameters}" href="#ESM_PINOQG3Ext.train_model-Tuple{AbstractArray, AbstractArray, QG3ModelParameters}"><code>ESM_PINOQG3Ext.train_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">train_model(
    x::AbstractArray,
    target::AbstractArray,
    pars::QG3ModelParameters;
    seed,
    maxiters,
    batchsize,
    modes,
    in_channels,
    out_channels,
    hidden_channels,
    n_layers,
    lifting_channel_ratio,
    projection_channel_ratio,
    channel_mlp_expansion,
    activation,
    positional_embedding,
    inner_skip,
    outer_skip,
    zsk,
    use_norm,
    downsampling_factor,
    lr_0,
    parameters,
    use_physics,
    geometric,
    α
) -&gt; Union{LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer{Val{true}, SFNO{GridEmbedding2D, L, _A, P, ESM_PINOQG3Ext.ESM_PINOQG3}, _A1, NamedTuple{names, T}} where {L&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A)), _A, P&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A)), _A1, names, T&lt;:Tuple}, LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer{Val{true}, SFNO{Lux.NoOpLayer, L, _A, P, ESM_PINOQG3Ext.ESM_PINOQG3}, _A1, NamedTuple{names, T}} where {L&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A)), _A, P&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A)), _A1, names, T&lt;:Tuple}}
</code></pre><p>Train an <code>SFNO</code> model with the possibility using a combined data-driven (simple MSE or geometrically weighted) and physics-informed loss. This function initializes the model, optimizer, and training loop, and performs iterative optimization of the model parameters.  </p><p>Both standard data loss and an optional physics-informed term are tracked during training.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: Input training data tensor.</li><li><code>target::AbstractArray</code>: Target (ground truth) data tensor.</li><li><code>pars::QG3ModelParameters</code>: Model configuration including grid and spectral parameters.</li></ul><p><strong>Keywords</strong></p><ul><li><code>seed::Int=0</code>: Random seed for reproducibility.</li><li><code>maxiters::Int=20</code>: Number of training iterations.</li><li><code>batchsize::Int=256</code>: Mini-batch size for training.</li><li><code>modes::Int=pars.L</code>: Spectral truncation level.</li><li><code>in_channels::Int=3</code>: Number of input channels.</li><li><code>out_channels::Int=3</code>: Number of output channels.</li><li><code>hidden_channels::Int=256</code>: Width of the hidden feature layers.</li><li><code>n_layers::Int=4</code>: Number of SFNO layers.</li><li><code>lifting_channel_ratio::Int=2</code>: Ratio of lifting layer expansion.</li><li><code>projection_channel_ratio::Int=2</code>: Ratio of projection layer contraction.</li><li><code>channel_mlp_expansion::Number=2.0</code>: Expansion factor in channel MLP blocks.</li><li><code>activation</code>: Activation function used in SFNO blocks (default: <code>NNlib.gelu</code>).</li><li><code>positional_embedding::AbstractString=&quot;grid&quot;</code>: Type of positional embedding (<code>&quot;grid&quot;</code> or <code>&quot;no_grid&quot;</code>).</li><li><code>inner_skip::Bool=true</code>: Whether to enable residual connections inside SFNO blocks.</li><li><code>outer_skip::Bool=true</code>: Whether to enable skip connections between lifting output and projection input.</li><li><code>zsk::Bool=false</code>: Use zonally symmetric kernel formulation if <code>true</code>.</li><li><code>use_norm::Bool=false</code>: Apply normalization layers inside SFNO blocks.</li><li><code>downsampling_factor::Int=2</code>: Ratio of downsampling between layers.</li><li><code>lr_0::Float64=1e-3</code>: Initial learning rate for the optimizer.</li><li><code>parameters::QG3_Physics_Parameters=QG3_Physics_Parameters(pars, batch_size=batchsize)</code>: Physical parameters used in the QG3 loss.</li><li><code>use_physics::Bool=true</code>: Whether to include the physics-informed loss component.</li><li><code>geometric::Bool=true</code>: Use geometrically weighted formulation for the data loss.</li><li><code>α::Float32=0.7f0</code>: Weighting factor between physics loss and data loss.</li></ul><p><strong>Returns</strong></p><ul><li><code>StatefulLuxLayer{true}</code>: Trained SFNO model containing learned parameters and internal state.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Initialize parameters and data
pars = qg3pars_constructor_helper(42, 64)
x, y = generate_training_data(pars)

# Train SFNO model
trained_model = train_model(x, y, pars; maxiters=100, batchsize=128, lr_0=5e-4)

# Perform inference
pred = trained_model(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/utilities.jl#L196-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ESM_PINOQG3Ext.transfer_SFNO_model-Tuple{SFNO, QG3ModelParameters}" href="#ESM_PINOQG3Ext.transfer_SFNO_model-Tuple{SFNO, QG3ModelParameters}"><code>ESM_PINOQG3Ext.transfer_SFNO_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transfer_SFNO_model(
    model::SFNO,
    qg3ppars::QG3ModelParameters;
    batch_size
) -&gt; Union{SFNO{GridEmbedding2D, L, _A, P, ESM_PINOQG3Ext.ESM_PINOQG3} where {L&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A)), _A, P&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A))}, SFNO{Lux.NoOpLayer, L, _A, P, ESM_PINOQG3Ext.ESM_PINOQG3} where {L&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A)), _A, P&lt;:(Lux.Chain{__T_layers, Nothing} where __T_layers&lt;:(NamedTuple{_A, &lt;:Tuple{Vararg{LuxCore.AbstractLuxLayer}}} where _A))}}
</code></pre><p>Construct a new <code>SFNO</code> model that replicates the architecture and parameters of an existing <code>model</code>, but adapts them to a new discretization (<code>qg3ppars</code>) and batch size.   This function preserves all spectral modes, channels, and hyperparameters while adjusting the internal transform plans to match the new grid configuration.</p><p><strong>Arguments</strong></p><ul><li><code>model::SFNO</code>: Source SFNO model whose architecture and parameters will be cloned.</li><li><code>qg3ppars</code>: Target problem parameters (e.g., grid, spectral resolution).</li></ul><p><strong>Keywords</strong></p><ul><li><code>batch_size::Int</code>: Optional new batch size. Defaults to the batch size inferred from <code>model.sfno_blocks.layers.layer_1.spherical_kernel.spherical_conv.plan.ggsh.FT_4d.plan.input_size[4]</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>SFNO</code>: A new model instance with the same architecture as <code>model</code>, configured for the target discretization and batch size.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Original model (batch size = 32)
model = SFNO(orig_pars; batch_size=32, ...)

# Transfer model to a finer grid and larger batch
new_model = transfer_SFNO_model(model, new_pars; batch_size=64)

# Forward pass with transferred weights
ŷ = new_model(x, ps, st)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/c0c4d5ba99caaa693cbfea90366af97c572a58ed/ext/ESM_PINOQG3Ext/utilities.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../ref/">« Reference</a><a class="docs-footer-nextpage" href="../SpeedyWeather/">SpeedyWeather Extension »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 7 November 2025 01:25">Friday 7 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
