<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · ESM_PINO.jl</title><meta name="title" content="Reference · ESM_PINO.jl"/><meta property="og:title" content="Reference · ESM_PINO.jl"/><meta property="twitter:title" content="Reference · ESM_PINO.jl"/><meta name="description" content="Documentation for ESM_PINO.jl."/><meta property="og:description" content="Documentation for ESM_PINO.jl."/><meta property="twitter:description" content="Documentation for ESM_PINO.jl."/><meta property="og:url" content="https://jackveneri.github.io/ESM_PINO.jl/ref/"/><meta property="twitter:url" content="https://jackveneri.github.io/ESM_PINO.jl/ref/"/><link rel="canonical" href="https://jackveneri.github.io/ESM_PINO.jl/ref/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ESM_PINO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li><li><a class="tocitem" href="../extensions/QG3/">QG3 Extension</a></li><li><a class="tocitem" href="../extensions/SpeedyWeather/">SpeedyWeather Extension</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jackveneri/ESM_PINO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jackveneri/ESM_PINO.jl/blob/master/docs/src/ref.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="ESM_PINO.AbstractSphericalConv"><a class="docstring-binding" href="#ESM_PINO.AbstractSphericalConv"><code>ESM_PINO.AbstractSphericalConv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSphericalConv &lt;: Lux.AbstractLuxLayer</code></pre><p>Abstract supertype for spherical convolution layers.</p><p>Concrete implementations are provided by extensions:</p><ul><li><code>ESM_PINOQG3Ext.SphericalConv</code>: QG3-based transforms.</li><li><code>ESM_PINOSpeedyWeatherExt.SphericalConv</code>: SpeedyWeather transforms.</li></ul><p>Load the corresponding extension to use a specific implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/Spherical_Conv.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.BurgersFD"><a class="docstring-binding" href="#ESM_PINO.BurgersFD"><code>ESM_PINO.BurgersFD</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BurgersFD{T}</code></pre><p>Finite-difference matrices for discretising the 1D Burgers equation using <strong>periodic boundary conditions</strong>.</p><p><strong>Initialization</strong></p><p><code>BurgersFD(T, n, Δx=1)</code>   <code>BurgersFD(grid::Grid{T})</code></p><p><strong>Arguments</strong></p><ul><li><code>T::DataType</code>: Element type</li><li><code>n::Integer</code>: Number of grid points</li><li><code>Δx::Number</code>: Grid spacing</li><li><code>grid::Grid{T}</code>: Grid object</li></ul><p><strong>Fields</strong></p><ul><li><code>M::AbstractMatrix{T}</code>: Second-derivative (Laplacian) matrix with periodic BCs</li><li><code>M2::AbstractMatrix{T}</code>: First-derivative (central differences) matrix with periodic BCs</li></ul><p><strong>Details</strong></p><ul><li><code>M</code> approximates ∂²/∂x² with periodic wrap-around.</li><li><code>M2</code> approximates ∂/∂x using central differences and periodic wrap-around.</li><li>Use these matrices for semi-discrete formulations of Burgers’ equation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FD_schemes.jl#L114-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.BurgersFD2"><a class="docstring-binding" href="#ESM_PINO.BurgersFD2"><code>ESM_PINO.BurgersFD2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BurgersFD2{T}</code></pre><p>Finite-difference matrices for the 1D Burgers equation with <strong>periodic boundary conditions</strong> using a <strong>backward-difference</strong> discretisation for the convective (first-derivative) term.</p><p><strong>Initialization</strong></p><p><code>BurgersFD2(T, n, Δx=1)</code>   <code>BurgersFD2(grid::Grid{T})</code></p><p><strong>Arguments</strong></p><ul><li><code>T::DataType</code>: Element type</li><li><code>n::Integer</code>: Number of grid points</li><li><code>Δx::Number</code>: Grid spacing</li><li><code>grid::Grid{T}</code>: Grid object</li></ul><p><strong>Fields</strong></p><ul><li><code>M::AbstractMatrix{T}</code>: Second-derivative (Laplacian) matrix with periodic BCs</li><li><code>M2::AbstractMatrix{T}</code>: First-derivative matrix using backward differences (periodic BCs)</li></ul><p><strong>Details</strong></p><ul><li><code>M</code> is identical in form to BurgersFD&#39;s Laplacian (periodic).</li><li><code>M2</code> is a backward-difference approximation of ∂/∂x; can improve stability for convection-dominated flows.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FD_schemes.jl#L209-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.BurgersFD_Dirichlet"><a class="docstring-binding" href="#ESM_PINO.BurgersFD_Dirichlet"><code>ESM_PINO.BurgersFD_Dirichlet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BurgersFD_Dirichlet{T}</code></pre><p>Finite-difference matrices for the 1D Burgers equation with <strong>Dirichlet boundary conditions</strong>.</p><p><strong>Initialization</strong></p><p><code>BurgersFD_Dirichlet(T, n, Δx=1)</code>   <code>BurgersFD_Dirichlet(grid::Grid{T})</code></p><p><strong>Arguments</strong></p><ul><li><code>T::DataType</code>: Element type</li><li><code>n::Integer</code>: Number of grid points</li><li><code>Δx::Number</code>: Grid spacing</li><li><code>grid::Grid{T}</code>: Grid object</li></ul><p><strong>Fields</strong></p><ul><li><code>M::AbstractMatrix{T}</code>: Second-derivative matrix with Dirichlet enforcement at boundaries</li><li><code>M2::AbstractMatrix{T}</code>: First-derivative matrix with boundary rows/cols zeroed</li></ul><p><strong>Details</strong></p><ul><li>Boundary rows/columns are zeroed to reflect fixed-value (Dirichlet) conditions.</li><li>Intended for Burgers’ problems with fixed boundary values (e.g., u=0 at domain ends).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FD_schemes.jl#L161-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.ChannelMLP"><a class="docstring-binding" href="#ESM_PINO.ChannelMLP"><code>ESM_PINO.ChannelMLP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ChannelMLP(channels::Int; expansion_factor=2.0, activation=gelu)</code></pre><p>Implements a channel-wise MLP with a skip connection.   Expects input in (height, width, channels, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>channels</code>: Number of input/output channels</li><li><code>expansion_factor</code>: Factor to expand hidden layer size (default: 2.0)</li><li><code>activation</code>: Nonlinear activation function in hidden layer (default: <code>NNlib.gelu</code>)</li></ul><p><strong>Fields</strong></p><ul><li><code>mlp::M</code>: Two-layer Conv-based MLP with hidden dimension = <code>expansion_factor * channels</code></li><li><code>skip::S</code>: Skip connection implemented as a <code>SoftGating</code> layer</li><li><code>expansion_factor::Number</code>: Factor controlling hidden dimension size</li></ul><p><strong>Details</strong></p><ul><li>Expands channels with a 1x1 convolution, applies nonlinearity, then projects back</li><li>Adds gated skip connection to stabilize training</li><li>Functions similarly to a feed-forward block in transformers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO_components.jl#L205-L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.ChannelMLP1D"><a class="docstring-binding" href="#ESM_PINO.ChannelMLP1D"><code>ESM_PINO.ChannelMLP1D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ChannelMLP1D(channels::Int; expansion_factor=0.5, activation=gelu)</code></pre><p>Implements a channel-wise MLP with a skip connection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO1D_components.jl#L60-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.ChannelMLP3D"><a class="docstring-binding" href="#ESM_PINO.ChannelMLP3D"><code>ESM_PINO.ChannelMLP3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ChannelMLP3D(channels::Int; expansion_factor=0.5, activation=gelu)</code></pre><p>Implements a channel-wise MLP with a skip connection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO3D_components.jl#L67-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.FDPhysicsLossParameters"><a class="docstring-binding" href="#ESM_PINO.FDPhysicsLossParameters"><code>ESM_PINO.FDPhysicsLossParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FDPhysicsLossParameters(ν::Float64, N_t::Int, t_max::Float64, t_min::Float64, Δt::Float64, x_σ::Float64, x_μ::Float64, M1_gpu::AbstractArray, M2_gpu::AbstractArray)</code></pre><p>Create a struct to hold parameters for finite difference physics loss.</p><p><strong>Fields</strong></p><ul><li><code>ν</code>: Viscosity (scalar)</li><li>&#39;t<em>step</em>length`: Time step length (scalar)</li><li><code>M1_gpu</code>: Second derivative FD matrix (GPU array)</li><li><code>M2_gpu</code>: First derivative FD matrix (GPU array)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/losses.jl#L157-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.FNO_Block"><a class="docstring-binding" href="#ESM_PINO.FNO_Block"><code>ESM_PINO.FNO_Block</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A block that combines a SpectralKernel with optional normalization and a ChannelMLP.   Expects input in (height, width, channels, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>channels</code>: Number of input/output channels</li><li><code>modes</code>: Tuple specifying number of low-frequency modes for the spectral convolution</li><li><code>expansion_factor</code>: Factor controlling hidden dimension size in ChannelMLP (default: 2)</li><li><code>activation</code>: Nonlinear activation function (default: <code>NNlib.gelu</code>)</li><li><code>use_norm</code>: Whether to use instance normalization after spectral kernel (default: false)</li></ul><p><strong>Fields</strong></p><ul><li><code>spectral_kernel::SpectralKernel</code>: Combines spectral and spatial convolutions</li><li><code>norm::Union{Lux.InstanceNorm, Lux.NoOpLayer}</code>: Optional normalization layer</li><li><code>channel_mlp::ChannelMLP</code>: Channel-wise MLP with skip connection</li><li><code>channels::Int</code>: Number of channels</li><li><code>modes::NTuple{2, Int}</code>: Retained Fourier modes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO_components.jl#L358">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.FNO_Block1D"><a class="docstring-binding" href="#ESM_PINO.FNO_Block1D"><code>ESM_PINO.FNO_Block1D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FNO_Block1D</code></pre><p>A block that combines a spectral kernel with a channel MLP. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO1D_components.jl#L122-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.FNO_Block3D"><a class="docstring-binding" href="#ESM_PINO.FNO_Block3D"><code>ESM_PINO.FNO_Block3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FNO_Block3D</code></pre><p>A block that combines a spectral kernel with a channel MLP. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO3D_components.jl#L170-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.FourierNeuralOperator"><a class="docstring-binding" href="#ESM_PINO.FourierNeuralOperator"><code>ESM_PINO.FourierNeuralOperator</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A Fourier Neural Operator (FNO) container that optionally includes positional embeddings, lifting and projection convolutions, and a stack of FNO blocks.</p><p><strong>Arguments</strong></p><ul><li><code>in_channels::Int</code>: Number of input channels.</li><li><code>out_channels::Int</code>: Number of output channels.</li><li><code>hidden_channels::Int=32</code>: Number of hidden channels used inside FNO blocks.</li><li><code>n_modes::NTuple{N,Int}=(16, 16)</code>: Number of retained Fourier modes per spatial dimension.</li><li><code>n_layers::Int=4</code>: Number of FNO blocks to stack.</li><li><code>lifting_channel_ratio::Int=2</code>: Channel expansion ratio used in the lifting layer.</li><li><code>projection_channel_ratio::Int=2</code>: Channel expansion ratio used in the projection layer.</li><li><code>channel_mlp_expansion::Number=2</code>: Expansion factor inside ChannelMLP of each block.</li><li><code>activation=NNlib.gelu</code>: Activation function used in conv layers.</li><li><code>positional_embedding</code>::AbstractString=&quot;grid&quot;: Choice of positional embedding:</li></ul><p>&quot;grid&quot;, &quot;no<em>grid&quot; =&gt; 2D variants (GridEmbedding2D or NoOpLayer) &quot;grid1D&quot;, &quot;no</em>grid1D&quot; =&gt; 1D variants (GridEmbedding1D or NoOpLayer) &quot;grid3D&quot;, &quot;no_grid3D&quot; =&gt; 3D variants (GridEmbedding3D or NoOpLayer)</p><ul><li><code>use_norm_in_blocks::Bool=false</code>: Whether to use normalization layers inside FNO blocks.</li></ul><p><strong>Fields</strong></p><ul><li><code>embedding</code>: Positional embedding layer (a GridEmbeddingND or NoOpLayer).</li><li><code>lifting</code>: Lifting convolution(s) mapping in<em>channels -&gt; hidden</em>channels.</li><li><code>fno_blocks</code>: Repeated stack of FNO blocks appropriate to dimensionality.</li><li><code>projection</code>: Projection convolution(s) mapping hidden<em>channels -&gt; out</em>channels.</li></ul><p><strong>Examples</strong></p><p>Example (2D data with grid embedding):</p><pre><code class="language-julia hljs">using Lux, Random, ESM_PINO

rng = Random.default_rng()

layer = FourierNeuralOperator(
    in_channels=3,
    out_channels=2,
    hidden_channels=32,
    n_modes=(12, 12),
    n_layers=4,
    positional_embedding=&quot;grid&quot;
)

ps = Lux.initialparameters(rng, layer)
st = Lux.initialstates(rng, layer)

# Input tensor (H, W, C, Batch)
x = randn(Float32, 64, 64, 3, 10)

y, st_new = layer(x, ps, st)
@show size(y)   # expect (64, 64, 2, 10)</code></pre><p>Another FNO example (1D data without grid embedding):</p><pre><code class="language-julia hljs">using Lux, Random, ESM_PINO

layer1d = FourierNeuralOperator(
    in_channels=1,
    out_channels=1,
    hidden_channels=16,
    n_modes=(8,),
    n_layers=3,
    positional_embedding=&quot;no_grid1D&quot;
)

x1 = randn(Float32, 128, 1, 5)   # (L, C, Batch)
y1, _ = layer1d(x1,
    Lux.initialparameters(rng, layer1d),
    Lux.initialstates(rng, layer1d)
)
@show size(y1)   # expect (128, 1, 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.GaussianGridEmbedding2D"><a class="docstring-binding" href="#ESM_PINO.GaussianGridEmbedding2D"><code>ESM_PINO.GaussianGridEmbedding2D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GaussianGridEmbedding2D(normalize_to::Vector{Vector{Float32}} = [[0f0, 1f0], [0f0, 1f0]])</code></pre><p>Positional embedding using Gaussian grid coordinates that adapts to input dimensions. Appends normalized latitude (Gaussian) and longitude (uniform) coordinates to the input. Expects input in (height, width, channels, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>normalize_to</code>: Vector of two intervals <code>[lat_min, lat_max]</code>, <code>[lon_min, lon_max]</code>  specifying the normalization range for coordinates</li></ul><p><strong>Fields</strong></p><ul><li><code>normalize_lat::Vector{Float32}</code>: Range boundaries for latitude normalization</li><li><code>normalize_lon::Vector{Float32}</code>: Range boundaries for longitude normalization</li></ul><p><strong>Details</strong></p><ul><li>Constructs Gaussian latitude grid based on input height</li><li>Constructs uniform longitude grid based on input width</li><li>Normalizes coordinates to specified ranges (default [0,1] × [0,1])</li><li>Repeats coordinate grids across batch dimension</li><li>Concatenates <code>grid_lat</code> and <code>grid_lon</code> as extra channels to the input</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/SFNO_components.jl#L70-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.Grid"><a class="docstring-binding" href="#ESM_PINO.Grid"><code>ESM_PINO.Grid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Grid{T}</code></pre><p>Discretization grid for 1D finite difference schemes.</p><p><strong>Initialization</strong></p><p><code>Grid(x)</code></p><p>with <code>x</code> an array or range with constant spacing.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector{T}</code>: Discretization points, assumed uniformly spaced.</li></ul><p><strong>Fields</strong></p><ul><li><code>N::Int</code>: Number of grid points</li><li><code>x::AbstractVector{T}</code>: Coordinates of grid points</li><li><code>Δx::T</code>: Grid spacing, computed from <code>x</code></li></ul><p><strong>Details</strong></p><ul><li>Computes <code>Δx</code> as the absolute difference between the first two grid points.</li><li>Useful for constructing finite-difference scheme matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FD_schemes.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.GridEmbedding2D"><a class="docstring-binding" href="#ESM_PINO.GridEmbedding2D"><code>ESM_PINO.GridEmbedding2D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GridEmbedding2D(grid_boundaries=[[0f0, 1f0], [0f0, 1f0]])</code></pre><p>Positional embedding that appends normalized 2D coordinates to the input.   Expects input in (height, width, channels, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>grid_boundaries</code>: Vector of two intervals <code>[x_min, x_max]</code>, <code>[y_min, y_max]</code> specifying coordinate range along each axis</li></ul><p><strong>Fields</strong></p><ul><li><code>boundaries_x::Vector{Float32}</code>: Range boundaries for x-coordinate</li><li><code>boundaries_y::Vector{Float32}</code>: Range boundaries for y-coordinate</li></ul><p><strong>Details</strong></p><ul><li>Constructs a 2D meshgrid of coordinates normalized to <code>[x_min, x_max] × [y_min, y_max]</code></li><li>Repeats coordinate grids across batch dimension</li><li>Concatenates <code>grid_x</code> and <code>grid_y</code> as extra channels to the input</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO_components.jl#L297-L314">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.GridEmbedding3D"><a class="docstring-binding" href="#ESM_PINO.GridEmbedding3D"><code>ESM_PINO.GridEmbedding3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GridEmbedding3D(grid_boundaries=[[0f0, 1f0], [0f0, 1f0], [0f0, 1f0]])</code></pre><p>Positional embedding that appends a normalized 3D coordinate grid to input data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO3D_components.jl#L112-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.NeumannFD"><a class="docstring-binding" href="#ESM_PINO.NeumannFD"><code>ESM_PINO.NeumannFD</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NeumannFD{T}</code></pre><p>Finite-difference operator for the first derivative with <strong>Neumann boundary conditions</strong> (enforcing zero derivative at the boundaries).</p><p><strong>Initialization</strong></p><p><code>NeumannFD(T, n, Δx=1)</code>   <code>NeumannFD(grid::Grid{T})</code></p><p><strong>Arguments</strong></p><ul><li><code>T::DataType</code>: Element type (e.g. <code>Float64</code>, <code>Float32</code>)</li><li><code>n::Integer</code>: Number of grid points</li><li><code>Δx::Number</code>: Grid spacing (default: 1)</li><li><code>grid::Grid{T}</code>: Grid object containing <code>N</code> and <code>Δx</code></li></ul><p><strong>Fields</strong></p><ul><li><code>M::AbstractMatrix{T}</code>: Finite-difference matrix representing the derivative operator</li></ul><p><strong>Details</strong></p><ul><li>Implements central differences for the interior and modifies boundary rows to enforce zero slope.</li><li>The returned operator approximates ∂/∂x with Neumann BCs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FD_schemes.jl#L38-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.PeriodicFD"><a class="docstring-binding" href="#ESM_PINO.PeriodicFD"><code>ESM_PINO.PeriodicFD</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PeriodicFD{T}</code></pre><p>Finite-difference operator for the first derivative with <strong>periodic boundary conditions</strong>.</p><p><strong>Initialization</strong></p><p><code>PeriodicFD(T, n, Δx=1)</code>   <code>PeriodicFD(grid::Grid{T})</code></p><p><strong>Arguments</strong></p><ul><li><code>T::DataType</code>: Element type</li><li><code>n::Integer</code>: Number of grid points</li><li><code>Δx::Number</code>: Grid spacing (default: 1)</li><li><code>grid::Grid{T}</code>: Grid object</li></ul><p><strong>Fields</strong></p><ul><li><code>M::AbstractMatrix{T}</code>: Finite-difference matrix representing the derivative operator</li></ul><p><strong>Details</strong></p><ul><li>Implements central differences and wraps the stencil at the domain boundaries (periodic).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FD_schemes.jl#L78-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SFNO"><a class="docstring-binding" href="#ESM_PINO.SFNO"><code>ESM_PINO.SFNO</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Empty layer to test extension documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/SFNO.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SFNO_Block"><a class="docstring-binding" href="#ESM_PINO.SFNO_Block"><code>ESM_PINO.SFNO_Block</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Empty layer to test extension documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/SFNO_components.jl#L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SoftGating"><a class="docstring-binding" href="#ESM_PINO.SoftGating"><code>ESM_PINO.SoftGating</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SoftGating(channels::Int)</code></pre><p>A soft gating layer that applies per-channel multiplicative scaling.   Expects input in (height, width, channels, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>channels</code>: Number of channels in the input</li></ul><p><strong>Fields</strong></p><ul><li><code>channels::Int</code>: Number of channels</li></ul><p><strong>Details</strong></p><ul><li>Learns a single scalar weight per channel</li><li>Weights are initialized to 1.0 (identity scaling)</li><li>Useful for lightweight residual or skip connections</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO_components.jl#L171-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SoftGating1D"><a class="docstring-binding" href="#ESM_PINO.SoftGating1D"><code>ESM_PINO.SoftGating1D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SoftGating1D(channels::Int)</code></pre><p>A soft gating layer that applies per-channel multiplicative scaling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO1D_components.jl#L38-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SoftGating3D"><a class="docstring-binding" href="#ESM_PINO.SoftGating3D"><code>ESM_PINO.SoftGating3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SoftGating3D(channels::Int)</code></pre><p>A soft gating layer that applies per-channel multiplicative scaling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO3D_components.jl#L45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SpectralConv"><a class="docstring-binding" href="#ESM_PINO.SpectralConv"><code>ESM_PINO.SpectralConv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpectralConv{T,N}</code></pre><p>Spectral convolution layer for Fourier Neural Operator in Lux.jl. Expects input in (spatial..., channel, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>in_channels</code>: Number of input channels</li><li><code>out_channels</code>: Number of output channels</li><li><code>modes</code>: Tuple specifying number of low-frequency modes to retain along each spatial dimension</li><li><code>T</code>: Data type for weights (default: ComplexF32)</li><li><code>N</code>: Number of spatial dimensions (inferred from length of <code>modes</code>)</li></ul><p><strong>Fields</strong></p><ul><li><code>in_channels::Int</code>: Number of input channels</li><li><code>out_channels::Int</code>: Number of output channels</li><li><code>modes::NTuple{N,Int}</code>: Number of low-frequency modes to retain along each spatial dimension</li></ul><p><strong>Details</strong></p><ul><li>Uses FFT to transform input to frequency domain, applies learned complex weights to low-frequency modes, and transforms back to spatial domain</li><li>Pads output back to original spatial dimensions after truncation</li><li>Weights are initialized with Glorot-like scaling</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO_components.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SpectralKernel"><a class="docstring-binding" href="#ESM_PINO.SpectralKernel"><code>ESM_PINO.SpectralKernel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpectralKernel{P,F}</code></pre><p>Combines a SpectralConv layer with a 1x1 convolution in parallel, followed by an activation function.   Expects input in (spatial..., channel, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>in_ch</code>: Number of input channels</li><li><code>out_ch</code>: Number of output channels</li><li><code>modes</code>: Tuple specifying number of low-frequency modes to retain in the spectral branch</li><li><code>activation</code>: Activation function applied after combining spatial and spectral branches (default: <code>NNlib.gelu</code>)</li></ul><p><strong>Fields</strong></p><ul><li><code>spatial_conv::P</code>: 1x1 convolution operating directly in the spatial domain</li><li><code>spectral_conv::SpectralConv</code>: Spectral convolution layer</li><li><code>activation::F</code>: Elementwise activation function</li></ul><p><strong>Details</strong></p><ul><li>The input is processed in parallel by a 1x1 convolution and a spectral convolution</li><li>Outputs from both branches are summed and passed through the activation</li><li>Useful for mixing local (spatial) and global (spectral) information</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO_components.jl#L111-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SpectralKernel1D"><a class="docstring-binding" href="#ESM_PINO.SpectralKernel1D"><code>ESM_PINO.SpectralKernel1D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpectralKernel1D{P,F}
Combines a SpectralConv layer with a 1x1 convolution in parallel, followed by an activation function.</code></pre><p>Expects input in (spatial, channel, batch) format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO1D_components.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SpectralKernel3D"><a class="docstring-binding" href="#ESM_PINO.SpectralKernel3D"><code>ESM_PINO.SpectralKernel3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpectralKernel3D{P,F}</code></pre><p>Combines a SpectralConv layer with a 1x1 convolution in parallel, followed by an activation function. Expects input in (spatial..., channel, batch) format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO3D_components.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SpectralPhysicsLossParameters"><a class="docstring-binding" href="#ESM_PINO.SpectralPhysicsLossParameters"><code>ESM_PINO.SpectralPhysicsLossParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpectralPhysicsLossParameters(ν::Float64, L::Float64, N_t::Int, t_max::Float64, t_min::Float64, Δt::Float64, x_σ::Float64, x_μ::Float64)</code></pre><p>Create a struct to hold parameters for spectral physics loss.</p><p><strong>Fields</strong></p><ul><li><code>ν</code>: Viscosity (scalar)</li><li><code>L</code>: Domain size (scalar)</li><li><code>N_t</code>: Number of time steps (integer)</li><li><code>t_max</code>: Maximum time (scalar)</li><li><code>t_min</code>: Minimum time (scalar)</li><li><code>Δt</code>: Time step size (scalar)</li><li><code>x_σ</code>: Standard deviation for normalization (scalar)</li><li><code>x_μ</code>: Mean for normalization (scalar)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/losses.jl#L95-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SphericalConv"><a class="docstring-binding" href="#ESM_PINO.SphericalConv"><code>ESM_PINO.SphericalConv</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Empty layer to test extension documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/Spherical_Conv.jl#L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SphericalKernel"><a class="docstring-binding" href="#ESM_PINO.SphericalKernel"><code>ESM_PINO.SphericalKernel</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Empty layer to test extension documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/SFNO_components.jl#L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.add_noise-Tuple{AbstractArray}"><a class="docstring-binding" href="#ESM_PINO.add_noise-Tuple{AbstractArray}"><code>ESM_PINO.add_noise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_noise(data::AbstractArray; noise_level::Real=0.1, noise_type::Symbol=:gaussian, relative::Bool=true, rng::AbstractRNG=Random.GLOBAL_RNG)</code></pre><p>Add random noise to an array, supporting Gaussian or uniform distributions.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractArray</code>: Input array to which noise will be added.</li><li><code>noise_level::Real=0.1</code>: Magnitude of the noise. Interpreted as standard deviation for Gaussian or half-width for uniform.</li><li><code>noise_type::Symbol=:gaussian</code>: Type of noise distribution. Options: <code>:gaussian</code> or <code>:uniform</code>.</li><li><code>relative::Bool=true</code>: If true, scale the noise level relative to the standard deviation of <code>data</code>.</li><li><code>rng::AbstractRNG=Random.GLOBAL_RNG</code>: Random number generator.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array</code>: A copy of <code>data</code> with added noise.</li></ul><p><strong>Details</strong></p><ul><li>For <code>:gaussian</code> noise, samples are drawn from a normal distribution with mean 0 and specified standard deviation.</li><li>For <code>:uniform</code> noise, samples are drawn uniformly from <code>[-noise_level, noise_level]</code>.</li><li>If <code>relative=true</code>, the noise magnitude is scaled by the standard deviation of <code>data</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; x = rand(10);

julia&gt; y = add_noise(x; noise_level=0.05, noise_type=:gaussian);

julia&gt; z = add_noise(x; noise_level=0.2, noise_type=:uniform, relative=false);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/utilities.jl#L1-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.apply_pattern-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T}}} where {T, N}"><a class="docstring-binding" href="#ESM_PINO.apply_pattern-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T}}} where {T, N}"><code>ESM_PINO.apply_pattern</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply_pattern(x_tr::AbstractArray{T,N}, weights::AbstractArray{T,3}) where {T,N}</code></pre><p>Apply learned weight patterns to truncated Fourier coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>x_tr::AbstractArray{T,N}</code>: Truncated Fourier coefficients after low-pass filtering, with shape (modes..., in_channels, batch)</li><li><code>weights::AbstractArray{T,4}</code>: Complex-valued learned weights with shape (modes..., out<em>channels, in</em>channels)</li></ul><p><strong>Returns</strong></p><ul><li>Weighted Fourier coefficients with shape (modes..., out_channels, batch)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO_components.jl#L64-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.autoregressive_loss-Tuple{LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer, Tuple{AbstractArray, AbstractArray}, Int64, ESM_PINO.FDPhysicsLossParameters, Float32}"><a class="docstring-binding" href="#ESM_PINO.autoregressive_loss-Tuple{LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer, Tuple{AbstractArray, AbstractArray}, Int64, ESM_PINO.FDPhysicsLossParameters, Float32}"><code>ESM_PINO.autoregressive_loss</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autoregressive_loss(model::StatefulLuxLayer, (u0, target)::Tuple{AbstractArray, AbstractArray}, n_steps::Int, params::FDPhysicsLossParameters, λ::Float32)</code></pre><p>Compute autoregressive loss for a model over multiple time steps.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: StatefulLuxLayer model</li><li><code>u0</code>: Initial state (input data)</li><li><code>target</code>: Target data for comparison</li><li><code>n_steps</code>: Number of time steps to propagate</li><li><code>params</code>: FDPhysicsLossParameters struct containing physics parameters</li><li><code>λ</code>: Weighting factor for physics loss</li></ul><p><strong>Returns</strong></p><ul><li>Total loss combining data loss and physics-informed loss</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/losses.jl#L229-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.compute_gaussian_latitudes-Tuple{Int64}"><a class="docstring-binding" href="#ESM_PINO.compute_gaussian_latitudes-Tuple{Int64}"><code>ESM_PINO.compute_gaussian_latitudes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Compute Gaussian latitudes using Newton&#39;s method to find roots of Legendre polynomials.
Returns latitudes in radians, sorted from North to South (decreasing order).
If n_lat is a common value (32 or 64), precomputed roots are returned to ensure consistency with precomputed available QG3 data.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/utilities.jl#L329-L333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.compute_k-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T&lt;:Real"><a class="docstring-binding" href="#ESM_PINO.compute_k-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T&lt;:Real"><code>ESM_PINO.compute_k</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_k(u::AbstractArray{T}, L::T) where T&lt;:Real</code></pre><p>Generate wavenumber array for spectral differentiation.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: Template array for dimensions</li><li><code>L</code>: Domain length</li></ul><p><strong>Returns</strong></p><ul><li><code>k</code>: Wavenumber array on GPU, reshaped for broadcasting</li></ul><p><strong>Details</strong></p><ul><li>Handles even/odd array sizes differently</li><li>Automatically converts to GPU array</li><li>Returns array with singleton dimensions for ND broadcasting</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/losses.jl#L34-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.create_physics_loss-Tuple{ESM_PINO.SpectralPhysicsLossParameters}"><a class="docstring-binding" href="#ESM_PINO.create_physics_loss-Tuple{ESM_PINO.SpectralPhysicsLossParameters}"><code>ESM_PINO.create_physics_loss</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_physics_loss()</code></pre><p>helper function to create a physics loss function.</p><p><strong>Arguments</strong></p><ul><li><code>params</code>: parameters struct, pass nothing to create a zero loss function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/losses.jl#L122-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.dealias-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, T}} where T&lt;:Real"><a class="docstring-binding" href="#ESM_PINO.dealias-Union{Tuple{T}, Tuple{AbstractArray{Complex{T}}, T}} where T&lt;:Real"><code>ESM_PINO.dealias</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dealias(u_hat::AbstractArray{Complex{T}}, L::T) where T&lt;:Real</code></pre><p>Apply 2/3 dealiasing filter to Fourier coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>u_hat</code>: Fourier coefficients (complex array)</li><li><code>L</code>: Domain length (unused in current implementation)</li></ul><p><strong>Returns</strong></p><ul><li>Filtered coefficients with high frequencies zeroed</li></ul><p><strong>Notes</strong></p><ul><li>Implements 2/3 rule for anti-aliasing</li><li>Creates mask directly on GPU</li><li>Preserves array dimensions for broadcasting</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/losses.jl#L67-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.denormalize_data-Tuple{AbstractArray, Any, Any}"><a class="docstring-binding" href="#ESM_PINO.denormalize_data-Tuple{AbstractArray, Any, Any}"><code>ESM_PINO.denormalize_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">denormalize_data(normalized_data, μ, σ; channelwise=false)</code></pre><p>Reverse the normalization applied by <code>normalize_data</code>.</p><p><strong>Arguments</strong></p><ul><li><code>normalized_data::AbstractArray</code>: Normalized data</li><li><code>μ</code>: Mean(s) used for normalization (scalar or vector)</li><li><code>σ</code>: Std(s) used for normalization (scalar or vector)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>channelwise::Bool=false</code>: Must match the mode used during normalization</li></ul><p><strong>Returns</strong></p><ul><li>Original scale data</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Global denormalization
data_original = denormalize_data(data_norm, μ, σ)

# Channel-wise denormalization
data_original = denormalize_data(data_norm, μ_vec, σ_vec, channelwise=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/utilities.jl#L222-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.expand_pad_dims-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><a class="docstring-binding" href="#ESM_PINO.expand_pad_dims-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N"><code>ESM_PINO.expand_pad_dims</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expand_pad_dims(pad_dims::Dims{N}) where {N}</code></pre><p>Convert N-dimensional padding specification into format required for NNlib&#39;s pad_constant function.</p><p><strong>Arguments</strong></p><ul><li><code>pad_dims::Dims{N}</code>: Tuple of N integers specifying the total padding needed along each dimension</li></ul><p><strong>Returns</strong></p><ul><li><code>NTuple{2N,Int}</code>: Tuple of 2N integers specifying padding for both sides of each dimension, where padding is applied only at the end of each dimension (start padding is always 0)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO_components.jl#L81-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.gaussian_grid-Tuple{Int64}"><a class="docstring-binding" href="#ESM_PINO.gaussian_grid-Tuple{Int64}"><code>ESM_PINO.gaussian_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Generate Gaussian grid with proper Gaussian latitudes using Legendre polynomials.
Returns latitudes in radians, sorted from North to South (decreasing order).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/utilities.jl#L298-L301">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.gaussian_latitudes-Tuple{Int64}"><a class="docstring-binding" href="#ESM_PINO.gaussian_latitudes-Tuple{Int64}"><code>ESM_PINO.gaussian_latitudes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gaussian_latitudes(nlat::Int) -&gt; Vector{Float64}</code></pre><p>Compute Gaussian latitude points (in degrees) for a grid with <code>nlat</code> latitudes. Uses Legendre polynomial roots for accurate Gaussian quadrature points.</p><p><strong>Arguments</strong></p><ul><li><code>nlat::Int</code>: Number of latitude points</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Latitude values in degrees from North to South pole</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/SFNO_components.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.legendre_and_derivative-Tuple{Int64, Vector{Float64}}"><a class="docstring-binding" href="#ESM_PINO.legendre_and_derivative-Tuple{Int64, Vector{Float64}}"><code>ESM_PINO.legendre_and_derivative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">legendre_and_derivative(n::Int, x::Vector{Float64}) -&gt; Tuple{Vector{Float64}, Vector{Float64}}</code></pre><p>Compute Legendre polynomial Pn and its derivative at points x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/SFNO_components.jl#L41-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.legendre_polynomial-Tuple{Int64, Float64}"><a class="docstring-binding" href="#ESM_PINO.legendre_polynomial-Tuple{Int64, Float64}"><code>ESM_PINO.legendre_polynomial</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Compute Legendre polynomial P_n(x) and its derivative using recurrence relation.
This uses the standard normalization where P_n(1) = 1.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/utilities.jl#L372-L375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.low_pass-Tuple{AbstractArray, Any}"><a class="docstring-binding" href="#ESM_PINO.low_pass-Tuple{AbstractArray, Any}"><code>ESM_PINO.low_pass</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">low_pass(x_ft, modes)</code></pre><p>Apply a low-pass filter to a Fourier-transformed array by retaining only the lowest frequency modes.</p><p><strong>Arguments</strong></p><ul><li><code>x_ft</code>: A Fourier-transformed array with at least 2 trailing dimensions</li><li><code>modes</code>: A tuple or array specifying the number of low-frequency modes to keep along each leading dimension</li></ul><p><strong>Returns</strong></p><ul><li>A view of the input array <code>x_ft</code> containing only the specified low-frequency modes, preserving the last two dimensions in full</li></ul><p><strong>Details</strong></p><p>The function creates a view that selects the first <code>modes[i]</code> elements along each leading dimension <code>i</code>, while keeping all elements of the last two dimensions. This effectively implements a low-pass filter in Fourier space by truncating high-frequency modes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO_components.jl#L43-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.meshgrid-Tuple{Any, Any}"><a class="docstring-binding" href="#ESM_PINO.meshgrid-Tuple{Any, Any}"><code>ESM_PINO.meshgrid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">meshgrid(x, y)</code></pre><p>Generates a 2D meshgrid from vectors <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/FNO_components.jl#L288-L292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.mse_loss_function-Tuple{LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer, AbstractArray, AbstractArray}"><a class="docstring-binding" href="#ESM_PINO.mse_loss_function-Tuple{LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer, AbstractArray, AbstractArray}"><code>ESM_PINO.mse_loss_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mse_loss_function(u::StatefulLuxLayer, target::AbstractArray, xt::AbstractArray)</code></pre><p>Standard mean squared error loss.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: Neural network</li><li><code>target</code>: Ground truth values</li><li><code>u_t1</code>: Network inputs</li></ul><p><strong>Returns</strong></p><ul><li>MSE between network output and target</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/losses.jl#L205-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.normalize_data-Tuple{AbstractArray}"><a class="docstring-binding" href="#ESM_PINO.normalize_data-Tuple{AbstractArray}"><code>ESM_PINO.normalize_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">normalize_data(data; channelwise=false, dims=nothing)</code></pre><p>Normalize data using mean and standard deviation.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractArray</code>: Input data to normalize</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>channelwise::Bool=false</code>: If true, normalize each channel independently</li><li><code>dims::Union{Nothing, Int, Tuple}=nothing</code>: Dimensions to compute statistics over. If <code>nothing</code>, behavior depends on <code>channelwise</code> and data shape.</li></ul><p><strong>Returns</strong></p><ul><li>Normalized data, mean(s), std(s)</li></ul><p><strong>Details</strong></p><p>When <code>channelwise=true</code>:</p><ul><li>Attempts to detect 4D format (lat, lon, channel, batch)</li><li>Computes per-channel statistics across spatial and batch dimensions</li><li>Returns vectors of means and stds (one per channel)</li></ul><p>When <code>channelwise=false</code>:</p><ul><li>Computes global statistics across all dimensions</li><li>Returns scalar mean and std</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Global normalization
data_norm, μ, σ = normalize_data(data)

# Channel-wise normalization (4D data)
data = randn(Float32, 48, 96, 5, 32)  # (lat, lon, channels, batch)
data_norm, μ_vec, σ_vec = normalize_data(data, channelwise=true)

# Custom dimensions
data_norm, μ, σ = normalize_data(data, dims=(1, 2, 4))  # Over lat, lon, batch</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/utilities.jl#L66-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.select_loss_function"><a class="docstring-binding" href="#ESM_PINO.select_loss_function"><code>ESM_PINO.select_loss_function</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">select_loss_function()</code></pre><p>Helper function to pass a valid loss function to Training.single<em>train</em>step. Selects a loss function based on the provided physics-informed loss function, in the standard workflow generated with create<em>physics</em>loss.</p><p><strong>Arguments</strong></p><ul><li><code>PI_loss</code>: Physics-informed loss function (default is a zero loss function)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/losses.jl#L330-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.spectral_derivative-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T&lt;:Real"><a class="docstring-binding" href="#ESM_PINO.spectral_derivative-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T&lt;:Real"><code>ESM_PINO.spectral_derivative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spectral_derivative(u::AbstractArray{T}, L::T) where T&lt;:Real</code></pre><p>Compute first and second spatial derivatives using FFT spectral methods.</p><p><strong>Arguments</strong></p><ul><li><code>u</code>: Input array (real-valued), assumed to be on GPU. First dimension is spatial.</li><li><code>L</code>: Domain length in spatial dimension.</li></ul><p><strong>Returns</strong></p><ul><li><code>du</code>: First derivative (real array)</li><li><code>d2u</code>: Second derivative (real array)</li></ul><p><strong>Notes</strong></p><ul><li>Uses FFT/iFFT with wavenumbers from <code>compute_k</code></li><li>Assumes periodic boundary conditions</li><li>Maintains input array type/location (GPU/CPU)</li><li>Output derivatives are real-valued arrays</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/src/losses.jl#L1-L19">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../extensions/QG3/">QG3 Extension »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 22:06">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
