<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QG3 Extension · ESM_PINO.jl</title><meta name="title" content="QG3 Extension · ESM_PINO.jl"/><meta property="og:title" content="QG3 Extension · ESM_PINO.jl"/><meta property="twitter:title" content="QG3 Extension · ESM_PINO.jl"/><meta name="description" content="Documentation for ESM_PINO.jl."/><meta property="og:description" content="Documentation for ESM_PINO.jl."/><meta property="twitter:description" content="Documentation for ESM_PINO.jl."/><meta property="og:url" content="https://jackveneri.github.io/ESM_PINO.jl/extensions/QG3/"/><meta property="twitter:url" content="https://jackveneri.github.io/ESM_PINO.jl/extensions/QG3/"/><link rel="canonical" href="https://jackveneri.github.io/ESM_PINO.jl/extensions/QG3/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ESM_PINO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../ref/">Reference</a></li><li class="is-active"><a class="tocitem" href>QG3 Extension</a></li><li><a class="tocitem" href="../SpeedyWeather/">SpeedyWeather Extension</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>QG3 Extension</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>QG3 Extension</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jackveneri/ESM_PINO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jackveneri/ESM_PINO.jl/blob/master/docs/src/extensions/QG3.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="QG3-Extension"><a class="docs-heading-anchor" href="#QG3-Extension">QG3 Extension</a><a id="QG3-Extension-1"></a><a class="docs-heading-anchor-permalink" href="#QG3-Extension" title="Permalink"></a></h1><p>This page documents the QG3-based SFNO layers and utility functions defined to work with the QG3 package</p><article><details class="docstring" open="true"><summary id="ESM_PINO.SFNO-Tuple{QG3.GaussianGridtoSHTransform, QG3.SHtoGaussianGridTransform}"><a class="docstring-binding" href="#ESM_PINO.SFNO-Tuple{QG3.GaussianGridtoSHTransform, QG3.SHtoGaussianGridTransform}"><code>ESM_PINO.SFNO</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SFNO(
    ggsh::QG3.GaussianGridtoSHTransform,
    shgg::QG3.SHtoGaussianGridTransform;
    in_channels,
    out_channels,
    hidden_channels,
    n_layers,
    num_encoder_layers,
    num_decoder_layers,
    lifting_channel_ratio,
    projection_channel_ratio,
    channel_mlp_expansion,
    activation,
    positional_embedding,
    inner_skip,
    outer_skip,
    operator_type,
    use_norm,
    downsampling_factor,
    modes,
    gpu,
    batch_size,
    soft_gating,
    bias
) -&gt; SFNO{E, L, B, P, ESM_PINOQG3Ext.ESM_PINOQG3} where {E, L, B, P}
</code></pre><p>Spherical Fourier Neural Operator (SFNO) layer combining positional embeddings, spectral kernels, and channel MLPs.</p><p>This layer implements the SFNO architecture on the sphere, optionally using Zonal Symmetric Kernels (ZSK) following the approach described in <a href="https://arxiv.org/abs/2204.06408"><strong>Spherical Fourier Neural Operators: Learning Stable Dynamics on the Sphere</strong></a>.</p><p><strong>Arguments</strong></p><ul><li><code>ggsh::QG3.GaussianGridtoSHTransform</code>: Precomputed grid-to-SH transform.</li><li><code>shgg::QG3.SHtoGaussianGridTransform</code>: Precomputed SH-to-grid transform.</li><li>Other keyword arguments are the same as for the primary constructor, except modes which default is set to <code>ggsh.output_size[1]</code>. Also, no need to specify <code>batch_size</code> or <code>gpu</code> as these are handled in the transforms.</li></ul><p><strong>Returns</strong></p><ul><li><code>SFNO</code>: A Lux-compatible container layer.</li></ul><p><strong>Details</strong></p><ul><li>Constructs lifting, SFNO blocks, and projection layers compatible with Lux.jl.</li><li>Positional embeddings are appended if <code>positional_embedding=&quot;grid&quot;</code>.</li><li>Supports both CPU and GPU execution.</li><li>Zonal Symmetric Kernels (ZSK) reduce the number of parameters and improve stability on spherical domains.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Lux, QG3, Random, NNlib, LuxCUDA

# Load precomputed QG3 parameters
qg3ppars = QG3.load_precomputed_params()[2]

# Input: [lat, lon, channels, batch]
x = rand(Float32, 32, 64, 3, 10)


# Construct SFNO layer using secondary constructor
ggsh = QG3.GaussianGridtoSHTransform(qg3ppars, 32, N_batch=size(x,4))
shgg = QG3.SHtoGaussianGridTransform(qg3ppars, 32, N_batch=size(x,4))
model2 = SFNO(ggsh, shgg;
    modes=15,
    in_channels=3,
    out_channels=3,
    hidden_channels=32,
    n_layers=4,
    lifting_channel_ratio=2,
    projection_channel_ratio=2,
    channel_mlp_expansion=2.0,
    positional_embedding=&quot;no_grid&quot;,
    outer_skip=true,
    zsk=true
)

# Setup parameters and state
rng = Random.default_rng(0)
ps, st = Lux.setup(rng, model2)

# Forward pass
y, st = model2(x, ps, st)

# Compute gradients
using Zygote
gr = Zygote.gradient(ps -&gt; sum(model2(x, ps, st)[1]), ps)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/SFNO.jl#L234">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SFNO-Tuple{QG3ModelParameters}"><a class="docstring-binding" href="#ESM_PINO.SFNO-Tuple{QG3ModelParameters}"><code>ESM_PINO.SFNO</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Modified SFNO constructor with variable encoder/decoder depths.</p><p><strong>New Arguments</strong></p><ul><li><code>num_encoder_layers::Int=2</code>: Number of layers in the encoder (lifting)</li><li><code>num_decoder_layers::Int=2</code>: Number of layers in the decoder (projection)</li></ul><p><strong>Notes</strong></p><ul><li>When <code>num_encoder_layers=2</code> and <code>num_decoder_layers=2</code>, this behaves identically to the original implementation</li><li><code>lifting_channel_ratio</code> controls the hidden dimension ratio for the encoder</li><li><code>projection_channel_ratio</code> controls the hidden dimension ratio for the decoder</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/SFNO.jl#L64-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SFNO_Block-Tuple{Int64, QG3.GaussianGridtoSHTransform, QG3.SHtoGaussianGridTransform}"><a class="docstring-binding" href="#ESM_PINO.SFNO_Block-Tuple{Int64, QG3.GaussianGridtoSHTransform, QG3.SHtoGaussianGridTransform}"><code>ESM_PINO.SFNO_Block</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SFNO_Block(
    channels::Int64,
    ggsh::QG3.GaussianGridtoSHTransform,
    shgg::QG3.SHtoGaussianGridTransform;
    modes,
    expansion_factor,
    activation,
    skip,
    operator_type,
    use_norm,
    soft_gating,
    bias
) -&gt; ESM_PINO.SFNO_Block{ESM_PINOQG3Ext.ESM_PINOQG3}
</code></pre><p>A block that combines a spherical kernel with a channel MLP. Expects input in (spatial..., channel, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>channels::Int</code>: Number of input/output channels</li><li><code>ggsh::GaussianGridtoSHTransform</code>: Transformation from Gaussian grid to spherical harmonics</li><li><code>shgg::SHtoGaussianGridTransform</code>: Transformation from spherical harmonics back to Gaussian</li><li><code>modes::Int=ggsh.output_size[1]</code>: Number of spherical harmonic modes to retain (default: <code>ggsh.output_size[1]</code>)</li><li><code>expansion_factor::Real=2.0</code>: Expansion factor for the ChannelMLP (default: 2.0)</li><li><code>activation</code>: Activation function applied after combining spatial and spectral branches (default: <code>NNlib.gelu</code>)</li><li><code>skip::Bool=true</code>: Whether to include a skip connection (default: true)</li><li><code>zsk::Bool=false</code>: Whether to use Zonal Symmetric Kernels (ZSK) (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>SFNO_Block</code>: A Lux-compatible layer operating on 4D arrays <code>[lat, lon, channels, batch]</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>spherical_kernel::SphericalKernel</code>: Spherical kernel layer</li><li><code>channel_mlp::ChannelMLP</code>: Channel-wise MLP layer</li><li><code>channels::Int</code>: Number of input/output channels</li><li><code>skip::Bool</code>: Whether to include a skip connection</li></ul><p>-<code>activation::Function</code>: Activation function applied after the block</p><p><strong>Details</strong></p><ul><li>The input is processed by a SphericalKernel followed by a ChannelMLP</li><li>If <code>skip</code> is true, the input is added to the output (residual connection)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/SFNO_components.jl#L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SFNO_Block-Tuple{Int64, QG3ModelParameters}"><a class="docstring-binding" href="#ESM_PINO.SFNO_Block-Tuple{Int64, QG3ModelParameters}"><code>ESM_PINO.SFNO_Block</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SFNO_Block(
    channels::Int64,
    pars::QG3ModelParameters;
    modes,
    batch_size,
    expansion_factor,
    activation,
    skip,
    gpu,
    operator_type,
    use_norm,
    soft_gating,
    bias
) -&gt; ESM_PINO.SFNO_Block{ESM_PINOQG3Ext.ESM_PINOQG3}
</code></pre><p>A block that combines a spherical kernel with a channel MLP. Expects input in (spatial..., channel, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>channels::Int</code>: Number of input/output channels</li><li><code>pars::QG3ModelParameters</code>: Precomputed QG3 model parameters (QG3ModelParameters)</li><li><code>modes::Int=pars.L</code>: Number of spherical harmonic modes to retain (default: <code>pars.L</code>)</li><li><code>batch_size::Int=1</code>: Batch size for transforms (default: 1)</li><li><code>expansion_factor::Real=2.0</code>: Expansion factor for the ChannelMLP (default: 2.0)</li><li><code>activation</code>: Activation function applied after combining spatial and spectral branches (default: <code>NNlib.gelu</code>)</li><li><code>skip::Bool=true</code>: Whether to include a skip connection (default: true)</li><li><code>gpu::Bool=true</code>: Whether to use GPU (default: true)</li><li><code>zsk::Bool=false</code>: Whether to use Zonal Symmetric Kernels (ZSK) (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>SFNO_Block</code>: A Lux-compatible layer operating on 4D arrays <code>[lat, lon, channels, batch]</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>spherical_kernel::SphericalKernel</code>: Spherical kernel layer</li><li><code>channel_mlp::ChannelMLP</code>: Channel-wise MLP layer</li><li><code>channels::Int</code>: Number of input/output channels</li><li><code>skip::Bool</code>: Whether to include a skip connection</li></ul><p>-<code>activation::Function</code>: Activation function applied after the block</p><p><strong>Details</strong></p><ul><li>The input is processed by a SphericalKernel followed by a ChannelMLP</li><li>If <code>skip</code> is true, the input is added to the output (residual connection)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/SFNO_components.jl#L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SphericalKernel-Tuple{Int64, QG3.GaussianGridtoSHTransform, QG3.SHtoGaussianGridTransform}"><a class="docstring-binding" href="#ESM_PINO.SphericalKernel-Tuple{Int64, QG3.GaussianGridtoSHTransform, QG3.SHtoGaussianGridTransform}"><code>ESM_PINO.SphericalKernel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SphericalKernel(
    hidden_channels::Int64,
    ggsh::QG3.GaussianGridtoSHTransform,
    shgg::QG3.SHtoGaussianGridTransform;
    use_norm,
    modes,
    operator_type,
    inner_mixing,
    bias
) -&gt; ESM_PINO.SphericalKernel{ESM_PINOQG3Ext.ESM_PINOQG3}
</code></pre><p>Construct a SphericalKernel layer using precomputed transforms.</p><p><strong>Arguments</strong></p><ul><li><code>hidden_channels::Int</code>: Number of channels</li><li><code>ggsh::GaussianGridtoSHTransform</code>: Transformation from Gaussian grid to spherical harmonics</li><li><code>shgg::SHtoGaussianGridTransform</code>: Transformation from spherical harmonics back to Gaussian grid</li><li><code>activation</code>: Activation function applied after combining spatial and spectral branches (default: <code>NNlib.gelu</code>)</li><li><code>modes::Int=ggsh.output_size[1]</code>: Number of spherical harmonic modes to retain (default: <code>ggsh.output_size[1]</code>)</li><li><code>zsk::Bool=false</code>: Whether to use Zonal Symmetric Kernels (ZSK) (default: false)</li></ul><p><strong>Returns</strong></p><ul><li><code>SphericalKernel</code>: A Lux-compatible layer operating on 4D arrays <code>[lat, lon, channels, batch]</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>spatial_conv::P</code>: 1x1 convolution operating directly in the spatial domain</li><li><code>spherical_conv::SphericalalConv</code>: Spherical convolution layer</li></ul><p>-<code>norm::Union{Lux.InstanceNorm, Lux.NoOpLayer}</code>: Optional normalization layer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/SFNO_components.jl#L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINO.SphericalKernel-Tuple{Int64, QG3ModelParameters}"><a class="docstring-binding" href="#ESM_PINO.SphericalKernel-Tuple{Int64, QG3ModelParameters}"><code>ESM_PINO.SphericalKernel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SphericalKernel(
    hidden_channels::Int64,
    pars::QG3ModelParameters;
    use_norm,
    modes,
    batch_size,
    gpu,
    operator_type,
    inner_mixing,
    bias
) -&gt; ESM_PINO.SphericalKernel{ESM_PINOQG3Ext.ESM_PINOQG3}
</code></pre><p>Combines a SphericalConv layer with a 1x1 convolution in parallel, followed by an activation function. Expects input in (spatial..., channel, batch) format.</p><p><strong>Arguments</strong></p><ul><li><code>hidden_channels</code>: Number of channels</li><li><code>pars</code>: Precomputed QG3 model parameters (QG3ModelParameters)</li><li><code>activation</code>: Activation function applied after combining spatial and spectral branches (default: <code>NNlib.gelu</code>)</li><li><code>modes</code>: Number of spherical harmonic modes to retain (default: <code>pars.L</code>)</li><li><code>batch_size</code>: Batch size for transforms (default: 1)</li><li><code>gpu</code>: Whether to use GPU (default: true)</li><li><code>zsk</code>: Whether to use Zonal Symmetric Kernels (ZSK) (default: false)</li></ul><p>#Returns</p><ul><li><code>SphericalKernel</code>: A Lux-compatible layer operating on 4D arrays `[lat,</li></ul><p><strong>Fields</strong></p><ul><li><code>spatial_conv::P</code>: 1x1 convolution operating directly in the spatial domain</li><li><code>spherical_conv::SphericalalConv</code>: Spherical convolution layer</li></ul><p>-<code>norm::Union{Lux.InstanceNorm, Lux.NoOpLayer}</code>: Optional normalization layer</p><p><strong>Details</strong></p><ul><li>The input is processed in parallel by a 1x1 convolution and a spherical convolution</li><li>Outputs from both branches are summed and passed through the activation</li><li>Useful for mixing local (spatial) and global (spectral) information</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/SFNO_components.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.GaussianGridInfo"><a class="docstring-binding" href="#ESM_PINOQG3Ext.GaussianGridInfo"><code>ESM_PINOQG3Ext.GaussianGridInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GaussianGridInfo</code></pre><p>Structure containing information about a Gaussian grid resolution.</p><p><strong>Fields</strong></p><ul><li><code>truncation::Int</code>: Spectral truncation number (e.g., 31 for T31)</li><li><code>nlat::Int</code>: Number of latitude points</li><li><code>nlon::Int</code>: Number of longitude points  </li><li><code>km_at_equator::Float64</code>: Approximate grid spacing at equator in km</li><li><code>deg_at_equator::Float64</code>: Approximate grid spacing at equator in degrees</li><li><code>description::String</code>: Human-readable description</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/gaussian_grid_utils.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.QG3_Physics_Parameters-Tuple{}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.QG3_Physics_Parameters-Tuple{}"><code>ESM_PINOQG3Ext.QG3_Physics_Parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">QG3_Physics_Parameters(
;
    n_lat,
    modes,
    batch_size,
    gpu
) -&gt; ESM_PINOQG3Ext.QG3_Physics_Parameters
</code></pre><p>Helper constructor to pass as empty default to train_model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/losses.jl#L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.build_encoder_decoder-Tuple{Int64, Int64, Int64, Int64, Any, Bool}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.build_encoder_decoder-Tuple{Int64, Int64, Int64, Int64, Any, Bool}"><code>ESM_PINOQG3Ext.build_encoder_decoder</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Helper function to build encoder/decoder layers with variable depth.</p><p><strong>Arguments</strong></p><ul><li><code>in_channels::Int</code>: Number of input channels</li><li><code>out_channels::Int</code>: Number of output channels  </li><li><code>hidden_channels::Int</code>: Number of hidden channels</li><li><code>n_layers::Int</code>: Number of layers (depth)</li><li><code>activation</code>: Activation function</li><li><code>bias::Bool</code>: Whether to use bias in convolutions</li></ul><p><strong>Returns</strong></p><ul><li><code>Lux.Chain</code>: Sequential chain of convolutional layers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/SFNO.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.calculate_gaussian_grid_size-Tuple{Int64}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.calculate_gaussian_grid_size-Tuple{Int64}"><code>ESM_PINOQG3Ext.calculate_gaussian_grid_size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_gaussian_grid_size(truncation::Int) -&gt; Tuple{Int, Int}</code></pre><p>Calculate Gaussian grid dimensions from spectral truncation number using standard formulas.</p><p>For a spectral truncation T, the standard relationships are:</p><ul><li>nlat = (truncation + 1) * 3 / 2  (for reduced grids, varies slightly)</li><li>nlon = 2 * nlat  (for regular grids)</li></ul><p><strong>Arguments</strong></p><ul><li><code>truncation::Int</code>: Spectral truncation number</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Int, Int}</code>: (nlat, nlon)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/gaussian_grid_utils.jl#L92-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.fine_tuning-Tuple{AbstractArray, AbstractArray, Any, NamedTuple, NamedTuple}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.fine_tuning-Tuple{AbstractArray, AbstractArray, Any, NamedTuple, NamedTuple}"><code>ESM_PINOQG3Ext.fine_tuning</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fine_tuning(
    x::AbstractArray,
    target::AbstractArray,
    model,
    ps::NamedTuple,
    st::NamedTuple;
    n_steps,
    maxiters,
    lr_0,
    gpu,
    parameters,
    use_physics,
    geometric,
    α
) -&gt; LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer{Val{true}, var&quot;#s179&quot;, _A, NamedTuple{names, T}} where {var&quot;#s179&quot;&lt;:LuxCore.AbstractLuxLayer, _A, names, T&lt;:Tuple}
</code></pre><p>Fine-tune a pretrained <code>SFNO</code> model using an autoregressive (AR) loss function.   This procedure is typically applied after initial training to improve multi-step forecast accuracy.</p><p>The function performs a short fine-tuning loop with autoregressive supervision, optionally including a physics-informed loss component.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: Input data tensor.</li><li><code>target::AbstractArray</code>: Target data tensor with shape <code>(lat, lon, channels, batch, time)</code>.</li><li><code>model</code>: Pretrained <code>SFNO</code> model to be fine-tuned.</li><li><code>ps::NamedTuple</code>: Model parameters (from previous training).</li><li><code>st::NamedTuple</code>: Model internal state.</li></ul><p><strong>Keywords</strong></p><ul><li><code>n_steps::Int=2</code>: Number of autoregressive steps in the loss function.</li><li><code>maxiters::Int=5</code>: Maximum number of fine-tuning iterations.</li><li><code>lr_0::Float64=1e-5</code>: Learning rate for fine-tuning.</li><li><code>parameters::QG3_Physics_Parameters=QG3_Physics_Parameters()</code>: Physical parameters used in the loss.</li><li><code>use_physics::Bool=true</code>: Include physics-informed component in the loss if <code>true</code>.</li><li><code>geometric::Bool=true</code>: Use geometric formulation of the physics loss.</li><li><code>α::Float32=0.7f0</code>: Weighting factor between physics and data loss terms.</li></ul><p><strong>Returns</strong></p><ul><li><code>StatefulLuxLayer{true}</code>: Fine-tuned model instance with updated parameters and states.</li></ul><p><strong>Notes</strong></p><ul><li>The target tensor must have five dimensions, with the number of autoregressive steps as the fifth dimension.</li><li>The time dimension (<code>size(target, 5)</code>) must match the number of autoregressive steps (<code>n_steps</code>).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Fine-tune a pretrained SFNO model for multi-step forecasting
ft_model = fine_tuning(x_val, y_val, pretrained_model, ps, st;
                       n_steps=3, maxiters=10, lr_0=1e-5)

# Evaluate fine-tuned model
pred = ft_model(x_val)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/utilities.jl#L626-L668">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.gaussian_resolution_to_grid-Tuple{AbstractString}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.gaussian_resolution_to_grid-Tuple{AbstractString}"><code>ESM_PINOQG3Ext.gaussian_resolution_to_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gaussian_resolution_to_grid(resolution::AbstractString) -&gt; Tuple{Int, Int}</code></pre><p>Convert a Gaussian grid resolution string (e.g., &quot;T31&quot;, &quot;T63&quot;) to (nlat, nlon) tuple.</p><p><strong>Arguments</strong></p><ul><li><code>resolution::AbstractString</code>: Grid resolution in format &quot;TN&quot; where N is truncation number</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Int, Int}</code>: (number of latitude points, number of longitude points)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; gaussian_resolution_to_grid(&quot;T31&quot;)
(48, 96)

julia&gt; gaussian_resolution_to_grid(&quot;T63&quot;)  
(96, 192)

julia&gt; gaussian_resolution_to_grid(&quot;T255&quot;)
(256, 512)</code></pre><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If resolution is not recognized</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/gaussian_grid_utils.jl#L45-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.get_truncation_from_nlat-Tuple{Int64}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.get_truncation_from_nlat-Tuple{Int64}"><code>ESM_PINOQG3Ext.get_truncation_from_nlat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_truncation_from_nlat(nlat::Int) -&gt; Int</code></pre><p>Retrieve the spectral truncation number for a given number of latitude points.</p><p><strong>Arguments</strong></p><ul><li><code>nlat::Int</code>: Number of latitude points</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Spectral truncation number (e.g., 31 for T31)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; get_truncation_from_nlat(48)
31

julia&gt; get_truncation_from_nlat(96)
63

julia&gt; get_truncation_from_nlat(256)
255</code></pre><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If nlat doesn&#39;t match any known Gaussian grid resolution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/gaussian_grid_utils.jl#L115-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.make_QG3_loss-Tuple{ESM_PINOQG3Ext.QG3_Physics_Parameters}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.make_QG3_loss-Tuple{ESM_PINOQG3Ext.QG3_Physics_Parameters}"><code>ESM_PINOQG3Ext.make_QG3_loss</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_QG3_loss(pars::QG3_Physics_Parameters;
              α=0.5f0,
              use_physics::Bool=true,
              geometric::Bool=false)</code></pre><p>Create a composite QG3 loss function suitable for Lux training. Returns a callable <code>(model, ps, st, (input, target)) -&gt; (loss, st, metrics)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/losses.jl#L142-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.make_autoregressive_loss-Tuple{Function}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.make_autoregressive_loss-Tuple{Function}"><code>ESM_PINOQG3Ext.make_autoregressive_loss</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_autoregressive_loss(QG3_loss::Function; steps::Int, sequential::Bool=true)</code></pre><p>Create an autoregressive loss function that rolls out predictions over <code>steps</code> and accumulates the loss defined by <code>QG3_loss</code>.</p><p><strong>Arguments</strong></p><ul><li><code>QG3_loss</code>: A loss function of the form <code>(model, ps, st, (input, target)) -&gt; (loss, st, details)</code></li><li><code>steps</code>: Number of autoregressive rollout steps</li><li><code>sequential</code>: If true, predictions are fed sequentially (standard autoregressive); if false, all predictions are computed and compared in batch for efficiency.</li></ul><p><strong>Returns</strong></p><ul><li>A loss function <code>(model, ps, st, (u_t1, targets)) -&gt; (loss, st, details)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/losses.jl#L189-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.preprocess_data-Tuple{AbstractArray}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.preprocess_data-Tuple{AbstractArray}"><code>ESM_PINOQG3Ext.preprocess_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">preprocess_data(solu::AbstractArray;
    noise_level::Real=0.0,
    normalize::Bool=true,
    channelwise::Bool=false,
    to_gpu::Bool=false,
    noise_type::Symbol=:gaussian,
    slice_range::Union{Nothing, UnitRange, Tuple}=nothing,
    train_fraction::Real=0.8
)</code></pre><p>Preprocess simulation data with normalization, noise injection, and train/validation splitting.</p><p><strong>Arguments</strong></p><ul><li><code>solu::AbstractArray</code>: Raw simulation data array of shape (lat, lon, channel, time)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>noise_level::Real=0.0</code>: Standard deviation of noise to add (0.0 = no noise)</li><li><code>normalize::Bool=true</code>: Whether to normalize the data</li><li><code>channelwise::Bool=false</code>: If true, normalize each channel independently</li><li><code>to_gpu::Bool=false</code>: If true, transfer data to GPU after preprocessing</li><li><code>noise_type::Symbol=:gaussian</code>: Type of noise (:gaussian, :uniform, :salt_pepper)</li><li><code>slice_range::Union{Nothing, UnitRange, Tuple}=nothing</code>: Optional range(s) to slice data</li><li><code>train_fraction::Real=0.8</code>: Fraction of data to use for training (rest used for validation)</li></ul><p><strong>Returns</strong></p><ul><li><code>q_0_train</code>: Training initial conditions</li><li><code>q_evolved_train</code>: Training evolved states</li><li><code>q_0_val</code>: Validation initial conditions</li><li><code>q_evolved_val</code>: Validation evolved states</li><li><code>μ</code>: Mean(s) used for normalization</li><li><code>σ</code>: Std(s) used for normalization</li><li><code>normalization_params</code>: NamedTuple with normalization metadata</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/utilities.jl#L1011-L1044">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.preprocess_data-Tuple{}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.preprocess_data-Tuple{}"><code>ESM_PINOQG3Ext.preprocess_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">preprocess_data(;
    noise_level::Real=0.0,
    normalize::Bool=true,
    channelwise::Bool=false,
    to_gpu::Bool=false,
    noise_type::Symbol=:gaussian,
    slice_range::Union{Nothing, UnitRange, Tuple}=nothing,
    train_fraction::Real=0.8
)</code></pre><p>Preprocess simulation data with normalization, noise injection, and train/validation splitting.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>noise_level::Real=0.0</code>: Standard deviation of noise to add (0.0 = no noise)</li><li><code>normalize::Bool=true</code>: Whether to normalize the data</li><li><code>channelwise::Bool=false</code>: If true, normalize each channel independently</li><li><code>to_gpu::Bool=false</code>: If true, transfer data to GPU after preprocessing</li><li><code>noise_type::Symbol=:gaussian</code>: Type of noise (:gaussian, :uniform, :salt_pepper)</li><li><code>slice_range::Union{Nothing, UnitRange, Tuple}=nothing</code>: Optional range(s) to slice data</li><li><code>train_fraction::Real=0.8</code>: Fraction of data to use for training (rest used for validation)</li></ul><p><strong>Returns</strong></p><ul><li><code>q_0_train</code>: Training initial conditions</li><li><code>q_evolved_train</code>: Training evolved states</li><li><code>q_0_val</code>: Validation initial conditions</li><li><code>q_evolved_val</code>: Validation evolved states</li><li><code>μ</code>: Mean(s) used for normalization</li><li><code>σ</code>: Std(s) used for normalization</li><li><code>normalization_params</code>: NamedTuple with normalization metadata</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic usage with 80% train, 20% validation
q0_tr, qe_tr, q0_val, qe_val, μ, σ, params = preprocess_data(
    normalize=true,
    train_fraction=0.8
)

# Custom train/val split with noise
q0_tr, qe_tr, q0_val, qe_val, μ, σ, params = preprocess_data(
    noise_level=0.01,
    normalize=true,
    channelwise=true,
    train_fraction=0.7,
    to_gpu=true
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/utilities.jl#L829-L877">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.qg3pars_constructor_helper-Tuple{Int64, Int64}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.qg3pars_constructor_helper-Tuple{Int64, Int64}"><code>ESM_PINOQG3Ext.qg3pars_constructor_helper</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qg3pars_constructor_helper(
    L::Int64,
    n_lat::Int64;
    n_lon,
    iters,
    tol,
    NF
) -&gt; QG3ModelParameters{Float32, Int64, Vector{Float32}, Matrix{Float32}}
</code></pre><p>Helper function to hook the constructor for QG3ModelParameters using a Gaussian grid. Generates latitude/longitude points and initializes empty topography and land/sea mask. Used mainly to handle SH transforms.</p><p><strong>Arguments</strong></p><p>-<code>L::Int</code>: Spectral truncation level (maximum degree).</p><ul><li><code>n_lat::Int</code>: Number of Gaussian latitudes.</li></ul><p><strong>Keywords</strong></p><ul><li><p><code>n_lon::Int=2*n_lat</code>: Number of longitudes (default: twice the latitude count).</p></li><li><p><code>iters::Int=100</code>: Maximum number of iterations for Gaussian grid convergence.</p></li><li><p><code>tol::Real=1e-8</code>: Convergence tolerance.</p></li><li><p><code>NF::Type{&lt;:AbstractFloat}=Float32</code>: Number format for outputs.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>QG3ModelParameters</code>: Model parameters including grid coordinates, topography (h),</li></ul><p>and land-sea mask (LS).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">pars = qg3pars_constructor_helper(42, 64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/utilities.jl#L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.remap_array_components-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Int64, Int64}} where T"><a class="docstring-binding" href="#ESM_PINOQG3Ext.remap_array_components-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Int64, Int64}} where T"><code>ESM_PINOQG3Ext.remap_array_components</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remap_array_components(arr::AbstractArray{T,4}, l::Int, c::Int) where T</code></pre><p>Remap a 4D array from ordering (0,-1,1,-2,2,...,-l,l) to (0,1,2,...,l,...,c,-1,-2,...,-l,...,-(c-1)).</p><p><strong>Arguments</strong></p><ul><li><code>arr</code>: 4D array of size (i, j, 2l+1, k) with third dimension in order: 0,-1,1,-2,2,...,-l,l</li><li><code>l</code>: Original maximum index (third dimension has 2l+1 elements)</li><li><code>c</code>: New maximum index (output third dimension will have 2c elements)</li></ul><p><strong>Returns</strong></p><ul><li>4D array of size (i, j, 2c, k) with reordered and padded third dimension</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># CPU example
arr = randn(3, 4, 5, 2)  # l=2, so 2*2+1=5
result = remap_array_components(arr, 2, 4)  # c=4, output size (3,4,8,2)

# GPU example
arr_gpu = CuArray(randn(3, 4, 5, 2))
result_gpu = remap_array_components(arr_gpu, 2, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/utilities.jl#L111-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.stack_time_steps-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Int64}} where T"><a class="docstring-binding" href="#ESM_PINOQG3Ext.stack_time_steps-Union{Tuple{T}, Tuple{AbstractArray{T, 4}, Int64}} where T"><code>ESM_PINOQG3Ext.stack_time_steps</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stack_time_steps(
    data::AbstractArray{T, 4},
    time_steps::Int64;
    dt,
    N_sims
) -&gt; Any
</code></pre><p>Convert a 4D tensor of sequential data <code>(lat, lon, channels, batch)</code> into a 5D tensor suitable for autoregressive training or evaluation.   The function constructs overlapping sequences along the batch dimension, each containing <code>time_steps</code> consecutive snapshots.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractArray{T,4}</code>: Input data tensor with dimensions <code>(lat, lon, channels, batch)</code>.</li><li><code>time_steps::Int</code>: Number of consecutive time steps to include in each sequence.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractArray{T,5}</code>: A 5D tensor of shape <code>(lat, lon, channels, time_steps, n_sequences)</code>, where <code>n_sequences = batch - time_steps + 1</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The resulting array can be used as autoregressive training targets for multi-step prediction.</li><li>Sequences are created by sliding a window of length <code>time_steps</code> along the batch axis.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Input: 4D array with 10 time samples
data = rand(Float32, 64, 128, 3, 10)

# Stack into 5D sequences of 4 time steps each
seq_data = stack_time_steps(data, 4)

@assert size(seq_data) == (64, 128, 3, 4, 7)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/utilities.jl#L756-L786">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.train_model-Tuple{AbstractArray, AbstractArray, QG3ModelParameters}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.train_model-Tuple{AbstractArray, AbstractArray, QG3ModelParameters}"><code>ESM_PINOQG3Ext.train_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">train_model(
    x::AbstractArray,
    target::AbstractArray,
    pars::QG3ModelParameters;
    seed,
    maxiters,
    batchsize,
    modes,
    in_channels,
    out_channels,
    hidden_channels,
    n_layers,
    lifting_channel_ratio,
    projection_channel_ratio,
    channel_mlp_expansion,
    activation,
    positional_embedding,
    inner_skip,
    outer_skip,
    operator_type,
    use_norm,
    downsampling_factor,
    lr_0,
    gpu,
    parameters,
    use_physics,
    geometric,
    α
) -&gt; LuxCore.StatefulLuxLayerImpl.StatefulLuxLayer{Val{true}, SFNO{E, L, B, P, Q}, _A, NamedTuple{names, T}} where {E, L, B, P, Q, _A, names, T&lt;:Tuple}
</code></pre><p>Train an <code>SFNO</code> model with the possibility using a combined data-driven (simple MSE or geometrically weighted) and physics-informed loss. This function initializes the model, optimizer, and training loop, and performs iterative optimization of the model parameters.  </p><p>Both standard data loss and an optional physics-informed term are tracked during training.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractArray</code>: Input training data tensor.</li><li><code>target::AbstractArray</code>: Target (ground truth) data tensor.</li><li><code>pars::QG3ModelParameters</code>: Model configuration including grid and spectral parameters.</li></ul><p><strong>Keywords</strong></p><ul><li><code>seed::Int=0</code>: Random seed for reproducibility.</li><li><code>maxiters::Int=20</code>: Number of training iterations.</li><li><code>batchsize::Int=256</code>: Mini-batch size for training.</li><li><code>modes::Int=pars.L</code>: Spectral truncation level.</li><li><code>in_channels::Int=3</code>: Number of input channels.</li><li><code>out_channels::Int=3</code>: Number of output channels.</li><li><code>hidden_channels::Int=256</code>: Width of the hidden feature layers.</li><li><code>n_layers::Int=4</code>: Number of SFNO layers.</li><li><code>lifting_channel_ratio::Int=2</code>: Ratio of lifting layer expansion.</li><li><code>projection_channel_ratio::Int=2</code>: Ratio of projection layer contraction.</li><li><code>channel_mlp_expansion::Number=2.0</code>: Expansion factor in channel MLP blocks.</li><li><code>activation</code>: Activation function used in SFNO blocks (default: <code>NNlib.gelu</code>).</li><li><code>positional_embedding::AbstractString=&quot;grid&quot;</code>: Type of positional embedding (<code>&quot;grid&quot;</code> or <code>&quot;no_grid&quot;</code>).</li><li><code>inner_skip::Bool=true</code>: Whether to enable residual connections inside SFNO blocks.</li><li><code>outer_skip::Bool=true</code>: Whether to enable skip connections between lifting output and projection input.</li><li><code>zsk::Bool=false</code>: Use zonally symmetric kernel formulation if <code>true</code>.</li><li><code>use_norm::Bool=false</code>: Apply normalization layers inside SFNO blocks.</li><li><code>downsampling_factor::Int=2</code>: Ratio of downsampling between layers.</li><li><code>lr_0::Float64=1e-3</code>: Initial learning rate for the optimizer.</li><li><code>parameters::QG3_Physics_Parameters=QG3_Physics_Parameters(pars, batch_size=batchsize)</code>: Physical parameters used in the QG3 loss.</li><li><code>use_physics::Bool=true</code>: Whether to include the physics-informed loss component.</li><li><code>geometric::Bool=true</code>: Use geometrically weighted formulation for the data loss.</li><li><code>α::Float32=0.7f0</code>: Weighting factor between physics loss and data loss.</li></ul><p><strong>Returns</strong></p><ul><li><code>StatefulLuxLayer{true}</code>: Trained SFNO model containing learned parameters and internal state.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Initialize parameters and data
pars = qg3pars_constructor_helper(42, 64)
x, y = generate_training_data(pars)

# Train SFNO model
trained_model = train_model(x, y, pars; maxiters=100, batchsize=128, lr_0=5e-4)

# Perform inference
pred = trained_model(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/utilities.jl#L205-L259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ESM_PINOQG3Ext.transfer_SFNO_model-Tuple{SFNO, QG3ModelParameters}"><a class="docstring-binding" href="#ESM_PINOQG3Ext.transfer_SFNO_model-Tuple{SFNO, QG3ModelParameters}"><code>ESM_PINOQG3Ext.transfer_SFNO_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transfer_SFNO_model(
    model::SFNO,
    qg3ppars::QG3ModelParameters;
    batch_size
) -&gt; SFNO{E, L, B, P, ESM_PINOQG3Ext.ESM_PINOQG3} where {E, L, B, P}
</code></pre><p>Construct a new <code>SFNO</code> model that replicates the architecture and parameters of an existing <code>model</code>, but adapts them to a new discretization (<code>qg3ppars</code>) and batch size.   This function preserves all spectral modes, channels, and hyperparameters while adjusting the internal transform plans to match the new grid configuration.</p><p><strong>Arguments</strong></p><ul><li><code>model::SFNO</code>: Source SFNO model whose architecture and parameters will be cloned.</li><li><code>qg3ppars</code>: Target problem parameters (e.g., grid, spectral resolution).</li></ul><p><strong>Keywords</strong></p><ul><li><code>batch_size::Int</code>: Optional new batch size. Defaults to the batch size inferred from <code>model.sfno_blocks.layers.layer_1.spherical_kernel.spherical_conv.plan.ggsh.FT_4d.plan.input_size[4]</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>SFNO</code>: A new model instance with the same architecture as <code>model</code>, configured for the target discretization and batch size.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Original model (batch size = 32)
model = SFNO(orig_pars; batch_size=32, ...)

# Transfer model to a finer grid and larger batch
new_model = transfer_SFNO_model(model, new_pars; batch_size=64)

# Forward pass with transferred weights
ŷ = new_model(x, ps, st)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jackveneri/ESM_PINO.jl/blob/168c551015342be20332f19d9008b84b871b3904/ext/ESM_PINOQG3Ext/utilities.jl#L1">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../ref/">« Reference</a><a class="docs-footer-nextpage" href="../SpeedyWeather/">SpeedyWeather Extension »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 28 November 2025 22:06">Friday 28 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
